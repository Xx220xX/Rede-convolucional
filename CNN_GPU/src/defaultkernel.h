#ifndef KERNELS_H
#define KERNELS_H
const char default_kernel[] = 
/*1*/		"//utils.h\n"
/*2*/		"// Created by Xx220xX on 10/05/2020.\n"
/*3*/		"\n"
/*4*/		"#define Vector __global double *\n"
/*5*/		"\n"
/*6*/		"#define kV __kernel void\n"
/*7*/		"\n"
/*8*/		"#define TensorMap(x, y, z, tx, ty)((z)*(ty*tx)+(x)*ty+(y))\n"
/*9*/		"\n"
/*10*/		"#define TensorMap4D(x, y, z, l, tx, ty, tz)((l)*(ty)*(tx)*(tz)+(z)*(ty*tx)+(x)*ty+(y))\n"
/*11*/		"\n"
/*12*/		"#define TensorRemap4D(total, _x_, _y_, _z_, _l_, tx, ty, tz)\\\n"
/*13*/		"_y_ = total%ty      ;                                        \\\n"
/*14*/		"_x_ = (total - _y_)%(ty*tx)/ty ;                             \\\n"
/*15*/		"_z_ = (total- _x_*ty - _y_)%(tx*ty*tz)/(ty*tx)  ;            \\\n"
/*16*/		"_l_ = (total -_z_*tx*ty -_x_*ty - _y_)/(tx*ty*tz);\n"
/*17*/		"\n"
/*18*/		"\n"
/*19*/		"#define TensorRemap(total, _x_, _y_, _z_, tx, ty)\\\n"
/*20*/		"_y_ = total % ty;\\\n"
/*21*/		"_x_ = ((total - _y_) % (ty * tx)) / ty;\\\n"
/*22*/		"_z_ = (k - _x_ * ty - _y_) / (tx * ty);\n"
/*23*/		"\n"
/*24*/		"#define TensorRemap2D(total, x, y, ty)\\\n"
/*25*/		"y = total % ty;\\\n"
/*26*/		"x = total/ ty;\n"
/*27*/		"\n"
/*28*/		"typedef struct {\n"
/*29*/		"	int x, y, z;\n"
/*30*/		"} Ponto3d;\n"
/*31*/		"\n"
/*32*/		"typedef struct {\n"
/*33*/		"	Ponto3d min, max;\n"
/*34*/		"} Range;\n"
/*35*/		"\n"
/*36*/		"kV createImg(__global unsigned char *out, Vector v, int vx, int vy, int imi, int imy, int k0) {\n"
/*37*/		"	int k = get_global_id(0) + k0;\n"
/*38*/		"	int i, j, z;\n"
/*39*/		"	TensorRemap(k, i, j, z, vx, vy)\n"
/*40*/		"	imi = imi + i;\n"
/*41*/		"	int imj = j + z * vy + z;\n"
/*42*/		"	out[imi * imy + imj] = ((int) v[k]) & 0xff;\n"
/*43*/		"}\n"
/*44*/		"\n"
/*45*/		"kV printTensor(Vector t, int mx, int my, int mz, int ofset) {\n"
/*46*/		"	for (int z = 0; z < mz; z++) {\n"
/*47*/		"		printf(\"[Dim%d]\\n\", z);\n"
/*48*/		"		for (int x = 0; x < mx; x++) {\n"
/*49*/		"			for (int y = 0; y < my; y++) {\n"
/*50*/		"\n"
/*51*/		"				printf(\"%.4lf \\t\", t[TensorMap(x, y, z, mx, my) + ofset]);\n"
/*52*/		"			}\n"
/*53*/		"			printf(\"\\n\");\n"
/*54*/		"		}\n"
/*55*/		"	}\n"
/*56*/		"}\n"
/*57*/		"\n"
/*58*/		"kV norm(Vector v, Vector out, int len) {\n"
/*59*/		"	double s = 0;\n"
/*60*/		"	for (int i = 0; i < len; ++i) {\n"
/*61*/		"		s += v[i] * v[i];\n"
/*62*/		"	}\n"
/*63*/		"	out[0] = pow(s, 0.5);\n"
/*64*/		"}\n"
/*65*/		"\n"
/*66*/		"kV maxID(Vector v, Vector out, int len) {\n"
/*67*/		"	int s = 0;\n"
/*68*/		"	for (int i = 1; i < len; ++i) {\n"
/*69*/		"		if (v[s] < v[i]) {\n"
/*70*/		"			s = i;\n"
/*71*/		"		}\n"
/*72*/		"	}\n"
/*73*/		"	out[0] = (double) s;\n"
/*74*/		"}\n"
/*75*/		"\n"
/*76*/		"kV\n"
/*77*/		"normalizeVector(Vector input, Vector saida, double multiplicador, double somador, double subtrator,\n"
/*78*/		"                int k0) {\n"
/*79*/		"	int k = get_global_id(0) + k0;\n"
/*80*/		"	saida[k] = (input[k] + somador) * multiplicador - subtrator;\n"
/*81*/		"}\n"
/*82*/		"\n"
/*83*/		"kV findExtremes(Vector input, Vector output, int len) {\n"
/*84*/		"	double mn = input[0], mx = input[0];\n"
/*85*/		"	for (int i = 1; i < len; ++i) {\n"
/*86*/		"		if (input[i] > mx) mx = input[i];\n"
/*87*/		"		if (input[i] < mn) mn = input[i];\n"
/*88*/		"	}\n"
/*89*/		"	output[0] = mn;\n"
/*90*/		"	output[1] = mx;\n"
/*91*/		"}\n"
/*92*/		"\n"
/*93*/		"kV sub(Vector grad, Vector saida, Vector target, int k0) {\n"
/*94*/		"	int k = get_global_id(0) + k0;\n"
/*95*/		"\n"
/*96*/		"	grad[k] = saida[k] - target[k];\n"
/*97*/		"}\n"
/*98*/		"\n"
/*99*/		"kV div(Vector v, double value, int k0) {\n"
/*100*/		"	int k = get_global_id(0) + k0;\n"
/*101*/		"	v[k] = v[k] / value;\n"
/*102*/		"}\n"
/*103*/		"\n"
/*104*/		"kV divIntDo(__global unsigned char *src, Vector v, double value, int k0) {\n"
/*105*/		"	int k = get_global_id(0) + k0;\n"
/*106*/		"	v[k] = ((double) src[k]) / value;\n"
/*107*/		"}\n"
/*108*/		"\n"
/*109*/		"kV int2vector(__global unsigned char *ints, Vector v, int noptiobs, int k0) {\n"
/*110*/		"	int k = get_global_id(0) + k0;\n"
/*111*/		"	for (int j = 0; j < noptiobs; j++) {\n"
/*112*/		"		v[k * noptiobs + j] = (double) (j == ints[k]);\n"
/*113*/		"	}\n"
/*114*/		"}\n"
/*115*/		"\n"
/*116*/		"\n"
/*117*/		"int normaliza_range(double f, int max, int lim_min) {\n"
/*118*/		"	if (f <= 0)return 0;\n"
/*119*/		"	if (f >= max - 1)return max - 1;\n"
/*120*/		"	if (lim_min) return ceil(f);\n"
/*121*/		"	else return floor(f);\n"
/*122*/		"}\n"
/*123*/		"\n"
/*124*/		"Range mapeia_entrada_saida(int x, int y, int passo, int tamanhoFiltro, int saidatx, int saidaty, int numeroFiltros) {\n"
/*125*/		"	double a = x, b = y;\n"
/*126*/		"	Range r;\n"
/*127*/		"	r.min.x = normaliza_range((a - tamanhoFiltro + 1) / passo, saidatx, 1);\n"
/*128*/		"	r.min.y = normaliza_range((b - tamanhoFiltro + 1) / passo, saidaty, 1);\n"
/*129*/		"	r.min.z = 0;\n"
/*130*/		"\n"
/*131*/		"	r.max.x = normaliza_range(a / passo, saidatx, 0);\n"
/*132*/		"	r.max.y = normaliza_range(b / passo, saidaty, 0);\n"
/*133*/		"	r.max.z = numeroFiltros - 1;\n"
/*134*/		"	return r;\n"
/*135*/		"}\n"
/*136*/		"\n"
/*137*/		"//bathnorm.h\n"
/*138*/		"\n"
/*139*/		"// achar a media\n"
/*140*/		"kV BatchNormMedia(Vector entrada, Vector media,\n"
/*141*/		"                  int entradatx, int entradaty, int k0) {\n"
/*142*/		"	int z = get_global_id(0) + k0;\n"
/*143*/		"	int x, y;\n"
/*144*/		"	double m = 0;\n"
/*145*/		"	for (x = 0; x < entradatx; x++) {\n"
/*146*/		"		for (y = 0; y < entradaty; y++) {\n"
/*147*/		"			m += entrada[TensorMap(x, y, z, entradatx, entradaty)];\n"
/*148*/		"		}\n"
/*149*/		"	}\n"
/*150*/		"	media[z] = m / (double) (entradatx * entradaty);\n"
/*151*/		"}\n"
/*152*/		"\n"
/*153*/		"// achar a diferenca\n"
/*154*/		"kV BatchNormDiferenca(Vector entrada, Vector media,\n"
/*155*/		"                      Vector diferenca,\n"
/*156*/		"                      Vector diferencaquad,\n"
/*157*/		"                      int entradatx, int entradaty, int k0) {\n"
/*158*/		"	int x, y, z;\n"
/*159*/		"	int k = get_global_id(0) + k0;\n"
/*160*/		"	TensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*161*/		"	diferenca[k] = entrada[k] - media[z];\n"
/*162*/		"	diferencaquad[k] = diferenca[k] * diferenca[k];\n"
/*163*/		"}\n"
/*164*/		"\n"
/*165*/		"kV BatchNormVariance(Vector dif, Vector difQuad,\n"
/*166*/		"                     Vector sumdiferenca, Vector variancia,\n"
/*167*/		"                     double episolon, int diftx, int difty,\n"
/*168*/		"                     int k0) {\n"
/*169*/		"	int z = get_global_id(0) + k0;\n"
/*170*/		"	double sum = 0;\n"
/*171*/		"	double sumdif = 0;\n"
/*172*/		"	for (int x = 0; x < diftx; x++) {\n"
/*173*/		"		for (int y = 0; y < difty; y++) {\n"
/*174*/		"			sum += difQuad[TensorMap(x, y, z, diftx, difty)];\n"
/*175*/		"			sumdif += dif[TensorMap(x, y, z, diftx, difty)];\n"
/*176*/		"		}\n"
/*177*/		"	}\n"
/*178*/		"	sumdiferenca[z] = sumdif;\n"
/*179*/		"	variancia[z] = sqrt(sum / (difty * diftx) + episolon);\n"
/*180*/		"}\n"
/*181*/		"\n"
/*182*/		"// normaliza\n"
/*183*/		"kV BatchNormNormaliza(Vector saida,\n"
/*184*/		"                      Vector norma,\n"
/*185*/		"                      Vector diferenca,\n"
/*186*/		"                      Vector variancia,\n"
/*187*/		"                      Vector Y,\n"
/*188*/		"                      Vector B,\n"
/*189*/		"                      int diferencatx, int diferencaty, int k0) {\n"
/*190*/		"	int x, y, z;\n"
/*191*/		"	int k = get_global_id(0) + k0;\n"
/*192*/		"	TensorRemap(k, x, y, z, diferencatx, diferencaty)\n"
/*193*/		"	norma[k] = diferenca[k] / variancia[z];\n"
/*194*/		"	saida[k] = norma[k] * Y[z] + B[z];\n"
/*195*/		"}\n"
/*196*/		"\n"
/*197*/		"\n"
/*198*/		"kV BatchNormaCalcGrad1(Vector gradIn,\n"
/*199*/		"                       Vector gradNext,\n"
/*200*/		"                       Vector variancia,\n"
/*201*/		"                       Vector media,\n"
/*202*/		"                       Vector Y,\n"
/*203*/		"\n"
/*204*/		"                       Vector somaDif,\n"
/*205*/		"                       Vector entrada,\n"
/*206*/		"                       int entradatx,\n"
/*207*/		"                       int entradaty,\n"
/*208*/		"                       int k0) {\n"
/*209*/		"	int x, y, z;\n"
/*210*/		"	int k = get_global_id(0) + k0;\n"
/*211*/		"	TensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*212*/		"	double M = entradatx * entradaty;\n"
/*213*/		"	double dif_variance = somaDif[z] - entrada[k] + media[z] + (entrada[k] - media[z]) * (M - 1);\n"
/*214*/		"	dif_variance = dif_variance * -1.0 / (variancia[z] * M * M);\n"
/*215*/		"\n"
/*216*/		"	double didx = variancia[z] * (M - 1 / M) + (media[z] - entrada[k]) * dif_variance;\n"
/*217*/		"	didx = didx / (variancia[z] * variancia[z]);\n"
/*218*/		"	didx = didx * gradNext[k];\n"
/*219*/		"	gradIn[k] = didx * Y[z];\n"
/*220*/		"}\n"
/*221*/		"\n"
/*222*/		"kV BatchNormaCalcGrad2(Vector gradNext,\n"
/*223*/		"                       Vector norma,\n"
/*224*/		"                       Vector gradY,\n"
/*225*/		"                       Vector gradB,\n"
/*226*/		"                       int entradatx,\n"
/*227*/		"                       int entradaty,\n"
/*228*/		"                       int k0) {\n"
/*229*/		"	int z = get_global_id(0) + k0;\n"
/*230*/		"	double sumY = 0;\n"
/*231*/		"	double sumB = 0;\n"
/*232*/		"	int k;\n"
/*233*/		"	for (int x = 0; x < entradatx; ++x) {\n"
/*234*/		"		for (int y = 0; y < entradaty; ++y) {\n"
/*235*/		"			k = TensorMap(x, y, z, entradatx, entradaty);\n"
/*236*/		"			sumY += gradNext[k];\n"
/*237*/		"			sumB += gradNext[k] * norma[k];\n"
/*238*/		"		}\n"
/*239*/		"	}\n"
/*240*/		"	gradB[z] = sumB;\n"
/*241*/		"	gradY[z] = sumY;\n"
/*242*/		"}\n"
/*243*/		"\n"
/*244*/		"\n"
/*245*/		"kV batchNormCorrigePeso(Vector gradY,\n"
/*246*/		"                        Vector gradB,\n"
/*247*/		"                        Vector Y,\n"
/*248*/		"                        Vector B,\n"
/*249*/		"                        double hitlearn,\n"
/*250*/		"                        int k0) {\n"
/*251*/		"	int z = get_global_id(0) + k0;\n"
/*252*/		"	B[z] = B[z] - gradB[z] * hitlearn;\n"
/*253*/		"	Y[z] = Y[z] - gradY[z] * hitlearn;\n"
/*254*/		"}\n"
/*255*/		"//conv.h\n"
/*256*/		"//#include\"utils.h\"\n"
/*257*/		"kV convSum(Vector filtro, Vector entrada, Vector saida,\n"
/*258*/		"           int passo, int saidatx, int saidaty, int entradatx, int entradaty,\n"
/*259*/		"           int lenFilter, int entradatz, int k0) {\n"
/*260*/		"	int k = get_global_id(0) + k0;\n"
/*261*/		"	int x, y, filtrok;\n"
/*262*/		"	TensorRemap(k, x, y, filtrok, saidatx, saidaty)\n"
/*263*/		"	Ponto3d mapeado = {x * passo, y * passo, 0};\n"
/*264*/		"	double sum = 0, f, v;\n"
/*265*/		"	for (int i = 0; i < lenFilter; i++)\n"
/*266*/		"		for (int j = 0; j < lenFilter; j++)\n"
/*267*/		"			for (int z = 0; z < entradatz; z++) {\n"
/*268*/		"				f = filtro[TensorMap4D(i, j, z, filtrok, lenFilter, lenFilter, entradatz)];\n"
/*269*/		"				v = entrada[TensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*270*/		"				sum += f * v;\n"
/*271*/		"			}\n"
/*272*/		"	saida[k] = sum;\n"
/*273*/		"}\n"
/*274*/		"\n"
/*275*/		"kV convFixWeight(Vector filtro, Vector grad, Vector gradOld, double hitlearn,\n"
/*276*/		"                 double momento, double weightDecay, int k0) {\n"
/*277*/		"	int k = get_global_id(0) + k0;\n"
/*278*/		"	double m = grad[k] + gradOld[k] * momento;\n"
/*279*/		"	double w = filtro[k];\n"
/*280*/		"	filtro[k] = w - hitlearn * (m + w * weightDecay);\n"
/*281*/		"	gradOld[k] = m;\n"
/*282*/		"}\n"
/*283*/		"\n"
/*284*/		"kV convCalcFiltro(     Vector ds,\n"
/*285*/		"					   Vector entrada,\n"
/*286*/		"					   Vector gradFiltro,\n"
/*287*/		"                       int gradFiltro_tx,\n"
/*288*/		"                       int gradFiltro_ty,\n"
/*289*/		"                       int gradFiltro_tz,\n"
/*290*/		"                       int entrada_tx,\n"
/*291*/		"                       int entrada_ty,\n"
/*292*/		"                       int saida_tx,\n"
/*293*/		"                       int saida_ty,\n"
/*294*/		"                       int passo,\n"
/*295*/		"                       int k0) {\n"
/*296*/		"	int k = get_global_id(0) + k0;\n"
/*297*/		"	int m, n, z, l;\n"
/*298*/		"//	printf(\"kernel %d\\n\",k);\n"
/*299*/		"	TensorRemap4D(k, m, n, z, l, gradFiltro_tx, gradFiltro_ty, gradFiltro_tz)\n"
/*300*/		"	double soma = 0;\n"
/*301*/		"	for (int i = 0; i < saida_tx; ++i) {\n"
/*302*/		"		for (int j = 0; j < saida_ty; ++j) {\n"
/*303*/		"			soma += entrada[TensorMap(i*passo+m, j*passo+n,z,entrada_tx,entrada_ty)]\n"
/*304*/		"				   *ds[TensorMap(i,j,l,saida_tx,saida_ty)];\n"
/*305*/		"		}\n"
/*306*/		"	}\n"
/*307*/		"	gradFiltro[k] = soma;\n"
/*308*/		"}\n"
/*309*/		"\n"
/*310*/		"kV convCalcGrads(Vector filtro,\n"
/*311*/		"				 Vector entrada,\n"
/*312*/		"                 Vector gradEntrada,\n"
/*313*/		"                 Vector gradNext,\n"
/*314*/		"                 int lenFilter,\n"
/*315*/		"                 int filtroz,\n"
/*316*/		"                 int passo,\n"
/*317*/		"                 int entradatx,\n"
/*318*/		"                 int entradaty,\n"
/*319*/		"                 int saidatx,\n"
/*320*/		"                 int saidaty,\n"
/*321*/		"                 int numFilters,\n"
/*322*/		"                 int k0) {\n"
/*323*/		"	int k = get_global_id(0) + k0;\n"
/*324*/		"	int x, y, z;\n"
/*325*/		"	TensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*326*/		"	Range range = mapeia_entrada_saida(x, y, passo, lenFilter, saidatx, saidaty, numFilters);\n"
/*327*/		"	int minX, minY;\n"
/*328*/		"	double somaErro = 0, pesoAplicado = 0;\n"
/*329*/		"\n"
/*330*/		"	for (int i = range.min.x; i <= range.max.x; i++) {\n"
/*331*/		"		minX = i * passo;\n"
/*332*/		"		for (int j = range.min.y; j <= range.max.y; j++) {\n"
/*333*/		"			minY = j * passo;\n"
/*334*/		"			for (int l = range.min.z; l <= range.max.z; l++) {\n"
/*335*/		"				pesoAplicado = filtro[TensorMap4D(x - minX, y - minY, z, l, lenFilter, lenFilter, filtroz)];\n"
/*336*/		"				somaErro += pesoAplicado * gradNext[TensorMap(i, j, l, saidatx, saidaty)];\n"
/*337*/		"			}\n"
/*338*/		"		}\n"
/*339*/		"	}\n"
/*340*/		"	gradEntrada[k] = somaErro;\n"
/*341*/		"}\n"
/*342*/		"\n"
/*343*/		"\n"
/*344*/		"//convNc.h\n"
/*345*/		"//#include\"utils.h\"\n"
/*346*/		"kV convncSum(Vector filtro, Vector entrada, Vector saida,\n"
/*347*/		"             int passox, int passoy, int largx,\n"
/*348*/		"             int largy, int saidatx, int saidaty,\n"
/*349*/		"             int entradatx, int entradaty,int fx, int fy,\n"
/*350*/		"             int entradatz, int k0) {\n"
/*351*/		"	int k = get_global_id(0) + k0;\n"
/*352*/		"	int x, y, filtrok;\n"
/*353*/		"	TensorRemap(k, x, y, filtrok, saidatx, saidaty)\n"
/*354*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*355*/		"	double sum = 0, f, v;\n"
/*356*/		"	for (int i = 0; i < fx; i++)\n"
/*357*/		"		for (int j = 0; j < fy; j++)\n"
/*358*/		"			for (int z = 0; z < entradatz; z++) {\n"
/*359*/		"				f = filtro[TensorMap4D(i, j, z, filtrok, fx, fy, entradatz)];\n"
/*360*/		"				v = entrada[TensorMap(mapeado.x + i * largx, mapeado.y + j * largy, z, entradatx, entradaty)];\n"
/*361*/		"				sum += f * v;\n"
/*362*/		"			}\n"
/*363*/		"	saida[k] = sum;\n"
/*364*/		"}\n"
/*365*/		"\n"
/*366*/		"kV convncFixWeight(Vector filtro, Vector grad, Vector gradOld,\n"
/*367*/		"				   double hitlearn,\n"
/*368*/		"                   double momento, double weightDecay, int k0) {\n"
/*369*/		"	int k = get_global_id(0) + k0;\n"
/*370*/		"	double m = grad[k] + gradOld[k] * momento;\n"
/*371*/		"	double w = filtro[k];\n"
/*372*/		"	filtro[k] = w - hitlearn * (m + w * weightDecay);\n"
/*373*/		"	gradOld[k] = m;\n"
/*374*/		"}\n"
/*375*/		"\n"
/*376*/		"kV convncCalcFiltro(Vector ds,\n"
/*377*/		"                    Vector entrada,\n"
/*378*/		"                    Vector gradFiltro,\n"
/*379*/		"                    int gradFiltro_tx,\n"
/*380*/		"                    int gradFiltro_ty,\n"
/*381*/		"                    int gradFiltro_tz,\n"
/*382*/		"\n"
/*383*/		"                    int entrada_tx,\n"
/*384*/		"                    int entrada_ty,\n"
/*385*/		"\n"
/*386*/		"                    int saida_tx,\n"
/*387*/		"                    int saida_ty,\n"
/*388*/		"\n"
/*389*/		"                    int passox,\n"
/*390*/		"                    int passoy,\n"
/*391*/		"\n"
/*392*/		"                    int largx,\n"
/*393*/		"                    int largy,\n"
/*394*/		"                    int k0) {\n"
/*395*/		"	int k = get_global_id(0) + k0;\n"
/*396*/		"	int m, n, z, l;\n"
/*397*/		"	TensorRemap4D(k, m, n, z, l, gradFiltro_tx, gradFiltro_ty, gradFiltro_tz)\n"
/*398*/		"	double soma = 0;\n"
/*399*/		"	for (int i = 0; i < saida_tx; ++i) {\n"
/*400*/		"		for (int j = 0; j < saida_ty; ++j) {\n"
/*401*/		"			soma += entrada[TensorMap(i * passox + m * largx, j * passoy + n * largy, z, entrada_tx, entrada_ty)]\n"
/*402*/		"			        * ds[TensorMap(i, j, l, saida_tx, saida_ty)];\n"
/*403*/		"		}\n"
/*404*/		"	}\n"
/*405*/		"	gradFiltro[k] = soma;\n"
/*406*/		"}\n"
/*407*/		"\n"
/*408*/		"/**\n"
/*409*/		" * equacao a ser implementada\n"
/*410*/		" * x = s*p + m*w\n"
/*411*/		" * onde:\n"
/*412*/		" * 	x é da entrada \n"
/*413*/		" * 	s é da saida\n"
/*414*/		" * 	m é do filtro\n"
/*415*/		" * 	s = (x - m*w)/p\n"
/*416*/		" */\n"
/*417*/		"kV convncCalcGrads(Vector filtro,\n"
/*418*/		"                   Vector entrada,\n"
/*419*/		"                   Vector gradEntrada,\n"
/*420*/		"                   Vector gradNext,\n"
/*421*/		"\n"
/*422*/		"                   int passox,\n"
/*423*/		"                   int passoy,\n"
/*424*/		"                   int largx,\n"
/*425*/		"                   int largy,\n"
/*426*/		"\n"
/*427*/		"                   int entradatx,\n"
/*428*/		"                   int entradaty,\n"
/*429*/		"                   int saidatx,\n"
/*430*/		"                   int saidaty,\n"
/*431*/		"\n"
/*432*/		"                   int fx,\n"
/*433*/		"                   int fy,\n"
/*434*/		"                   int fz,\n"
/*435*/		"                   int numFilters,\n"
/*436*/		"\n"
/*437*/		"                   int k0) {\n"
/*438*/		"	int k = get_global_id(0) + k0;\n"
/*439*/		"	int x, y, z;\n"
/*440*/		"	TensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*441*/		"	Range range_filtro ;\n"
/*442*/		"	range_filtro.min.x = 0;\n"
/*443*/		"	if ((entradatx - x - (fx - 1) * largx) < 0) {\n"
/*444*/		"		range_filtro.min.x = -entradatx + x + fx;\n"
/*445*/		"	}\n"
/*446*/		"	range_filtro.max.x = fx - 1;\n"
/*447*/		"	if (x - (fx - 1) * largx < 0) {\n"
/*448*/		"		range_filtro.max.x = x / largx;\n"
/*449*/		"	}\n"
/*450*/		"	range_filtro.min.y = 0;\n"
/*451*/		"	if ((entradaty - y - (fy - 1) * largy) < 0) {\n"
/*452*/		"		range_filtro.min.y = -entradaty + y + fy;\n"
/*453*/		"	}\n"
/*454*/		"	range_filtro.max.y = fy - 1;\n"
/*455*/		"	if (y - (fy - 1) * largy < 0) {\n"
/*456*/		"		range_filtro.max.y = y / largy;\n"
/*457*/		"	}\n"
/*458*/		"	int sx, sy;\n"
/*459*/		"	double somaErro = 0, pesoAplicado = 0;\n"
/*460*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*461*/		"		sx = (x - m * largx) / passox;\n"
/*462*/		"		if (sx * passox + m * largx != x)continue;\n"
/*463*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*464*/		"			sy = (y - n * largy) / passox;\n"
/*465*/		"			if (sy * passoy + n * largy != y)continue;\n"
/*466*/		"			for (int l = 0; l < fz; l++) {\n"
/*467*/		"				pesoAplicado = filtro[TensorMap4D(m, n, z, l, fx, fy, fz)];\n"
/*468*/		"				somaErro += pesoAplicado * gradNext[TensorMap(sx, sy, l, saidatx, saidaty)];\n"
/*469*/		"			}\n"
/*470*/		"		}\n"
/*471*/		"	}\n"
/*472*/		"	gradEntrada[k] = somaErro;\n"
/*473*/		"}\n"
/*474*/		"\n"
/*475*/		"\n"
/*476*/		"//dropout.h\n"
/*477*/		"#define MAX_INT_DP  ((1UL << 31) - 1)\n"
/*478*/		"long randoml(unsigned long seed,unsigned long id) {\n"
/*479*/		"	seed += id;\n"
/*480*/		"	return (seed * 0x5deece66dL + 0xbL) & MAX_INT_DP;\n"
/*481*/		"}\n"
/*482*/		"\n"
/*483*/		"double randomD(unsigned long seed,unsigned long id) {\n"
/*484*/		"	return (double) randoml(seed, id) / (double) MAX_INT_DP;\n"
/*485*/		"}\n"
/*486*/		"\n"
/*487*/		"kV dropativa(Vector entrada, Vector saida, __global char *hitmap, long seed,\n"
/*488*/		"			 double pativa, int k0) {\n"
/*489*/		"	int i = get_global_id(0) + k0;\n"
/*490*/		"//	printf(\"kernel %lf %lf %g %g\\n\",randomD(seed, i),pativa,(double)(seed +i),(double)MAX_INT_DP);\n"
/*491*/		"	char teste = (char) (randomD(seed, i) <= pativa);\n"
/*492*/		"	hitmap[i] = teste;\n"
/*493*/		"	saida[i] = teste * entrada[i];\n"
/*494*/		"}\n"
/*495*/		"\n"
/*496*/		"\n"
/*497*/		"kV dropcalcgrad(Vector gradentrada, __global char *hitmap, Vector gradnext, int k0) {\n"
/*498*/		"	int i = get_global_id(0) + k0;\n"
/*499*/		"	gradentrada[i] = hitmap[i] * gradnext[i];\n"
/*500*/		"}\n"
/*501*/		"\n"
/*502*/		"//fullconnect.h\n"
/*503*/		"double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }\n"
/*504*/		"\n"
/*505*/		"double difsigmoid(double x) {\n"
/*506*/		"	double tmp = sigmoid(x);\n"
/*507*/		"	return tmp * (1.0 - tmp);\n"
/*508*/		"}\n"
/*509*/		"\n"
/*510*/		"double tanghG(double x) { return tanh(x); }\n"
/*511*/		"\n"
/*512*/		"double diftanhG(double x) {\n"
/*513*/		"	double tmp = tanh(x);\n"
/*514*/		"	return (1.0 - tmp * tmp);\n"
/*515*/		"}\n"
/*516*/		"\n"
/*517*/		"double relu(double x) { return x > 0 ? x : 0.0; }\n"
/*518*/		"\n"
/*519*/		"double difrelu(double x) { return x > 0 ? 1.0 : 0.0; }\n"
/*520*/		"\n"
/*521*/		"double func(int id, double x) {\n"
/*522*/		"	switch (id) {\n"
/*523*/		"		case 0:\n"
/*524*/		"			return sigmoid(x);\n"
/*525*/		"		case 1:\n"
/*526*/		"			return difsigmoid(x);\n"
/*527*/		"		case 2:\n"
/*528*/		"			return tanghG(x);\n"
/*529*/		"		case 3:\n"
/*530*/		"			return diftanhG(x);\n"
/*531*/		"		case 4:\n"
/*532*/		"			return relu(x);\n"
/*533*/		"		case 5:\n"
/*534*/		"			return difrelu(x);\n"
/*535*/		"		default:\n"
/*536*/		"			return 0;\n"
/*537*/		"	}\n"
/*538*/		"}\n"
/*539*/		"\n"
/*540*/		"kV fullfeed(Vector entrada, Vector pesos, Vector z, Vector saida,\n"
/*541*/		"            int funcaoativacao, int inx, int iny, int inz, int pesosx, int pesosy, int k0) {\n"
/*542*/		"	int m = get_global_id(0) + k0;\n"
/*543*/		"	double valorEntrada = 0;\n"
/*544*/		"	int n;\n"
/*545*/		"	for (n = 0; n < pesosy; n++) {\n"
/*546*/		"		valorEntrada += entrada[n] * pesos[TensorMap(m, n, 0, pesosx, pesosy)];\n"
/*547*/		"	}\n"
/*548*/		"	z[m] = valorEntrada;\n"
/*549*/		"	saida[m] = func(funcaoativacao, valorEntrada);\n"
/*550*/		"}\n"
/*551*/		"\n"
/*552*/		"kV\n"
/*553*/		"fullfixweight(Vector a,\n"
/*554*/		"              Vector pesos,\n"
/*555*/		"              Vector dz,\n"
/*556*/		"              Vector dz_old,\n"
/*557*/		"              double hitlearn,\n"
/*558*/		"              double decaimentoDePeso,\n"
/*559*/		"              double momento,\n"
/*560*/		"              int inx,\n"
/*561*/		"              int iny,\n"
/*562*/		"              int inz,\n"
/*563*/		"              int pesosx,\n"
/*564*/		"              int pesosy,\n"
/*565*/		"              int k0) {\n"
/*566*/		"	int n = get_global_id(0) + k0;\n"
/*567*/		"	int m;\n"
/*568*/		"	double w;\n"
/*569*/		"	double tmp = dz[n] + dz_old[n] * momento;\n"
/*570*/		"	dz_old[n] = tmp;\n"
/*571*/		"	int k;\n"
/*572*/		"	for (m = inx * iny * inz - 1; m >= 0; m--) {\n"
/*573*/		"		k = TensorMap(n, m, 0, pesosx, pesosy);\n"
/*574*/		"		w = pesos[k];\n"
/*575*/		"		w -= hitlearn * (tmp * a[m] + w * decaimentoDePeso);\n"
/*576*/		"		pesos[k] = w;\n"
/*577*/		"	}\n"
/*578*/		"}\n"
/*579*/		"\n"
/*580*/		"kV fullcalcgrads1(Vector dz, Vector ds, Vector z, int dfa, int k0) {\n"
/*581*/		"	int m = get_global_id(0) + k0;\n"
/*582*/		"	dz[m] = ds[m] * func(dfa, z[m]);\n"
/*583*/		"}\n"
/*584*/		"\n"
/*585*/		"kV fullcalcgrads2(Vector dz, Vector da, Vector pesos, int pesosx, int pesosy,\n"
/*586*/		"                  int k0) {\n"
/*587*/		"	int m = get_global_id(0) + k0;\n"
/*588*/		"	double soma = 0;\n"
/*589*/		"	for (int n = 0; n < pesosx; ++n) {\n"
/*590*/		"		soma += dz[n] * pesos[TensorMap(n, m, 0, pesosx, pesosy)];\n"
/*591*/		"	}\n"
/*592*/		"	da[m] = soma;\n"
/*593*/		"}\n"
/*594*/		"\n"
/*595*/		"//padding.h\n"
/*596*/		"kV paddingfeed(Vector in,Vector out,\n"
/*597*/		"			   int txi,int tyi,\n"
/*598*/		"			   int txo,int tyo,\n"
/*599*/		"			   int t, int l ,\n"
/*600*/		"			   int k0){\n"
/*601*/		"	int k = get_global_id(0) + k0;\n"
/*602*/		"	int x, y, z;\n"
/*603*/		"	TensorRemap(k, x, y, z, txi, tyi)\n"
/*604*/		"	int s = TensorMap(x+t,y+l,z,txo,tyo);\n"
/*605*/		"	out[s] = in[k];\n"
/*606*/		"}\n"
/*607*/		"kV paddingBack(Vector gradNext,Vector gradin,\n"
/*608*/		"			   int txi,int tyi,\n"
/*609*/		"			   int txo,int tyo,\n"
/*610*/		"			   int t, int l , int k0){\n"
/*611*/		"	int k = get_global_id(0) + k0;\n"
/*612*/		"	int x, y, z;\n"
/*613*/		"	TensorRemap(k, x, y, z, txi, tyi)\n"
/*614*/		"	int s = TensorMap(x+t,y+l,z,txo,tyo);\n"
/*615*/		"	gradin[k] = gradNext[s];\n"
/*616*/		"}\n"
/*617*/		"//pool.h\n"
/*618*/		"kV poolativa(Vector entrada, Vector saida, int lenFilter,\n"
/*619*/		"             int passo, int saidatx, int saidaty, int entradatx, int entradaty, int k0) {\n"
/*620*/		"	int k = get_global_id(0) + k0;\n"
/*621*/		"	int x, y, z;\n"
/*622*/		"	TensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*623*/		"\n"
/*624*/		"	Ponto3d mapeado = {x * passo, y * passo, 0};\n"
/*625*/		"	double mval, v;\n"
/*626*/		"	mval = -DBL_MAX;\n"
/*627*/		"	for (int i = 0; i < lenFilter; ++i) {\n"
/*628*/		"		for (int j = 0; j < lenFilter; ++j) {\n"
/*629*/		"			v = entrada[TensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*630*/		"			if (v > mval)\n"
/*631*/		"				mval = v;\n"
/*632*/		"		}\n"
/*633*/		"	}\n"
/*634*/		"	saida[k] = mval;\n"
/*635*/		"}\n"
/*636*/		"\n"
/*637*/		"\n"
/*638*/		"kV\n"
/*639*/		"poolCalcGrads(Vector entrada, Vector gradEntrada, Vector gradNext, Vector saida,\n"
/*640*/		"              int lenFilter, int passo, int entradatx, int entradaty, int entradatz, int saidatx, int saidaty, int k0) {\n"
/*641*/		"	int k = get_global_id(0) + k0;\n"
/*642*/		"	int x, y;\n"
/*643*/		"	TensorRemap2D(k, x, y, entradaty)\n"
/*644*/		"	double somaErro = 0, testeMax;\n"
/*645*/		"	Range range;\n"
/*646*/		"	range = mapeia_entrada_saida(x, y, passo, lenFilter, saidatx, saidaty, 1);\n"
/*647*/		"	for (int z = 0; z < entradatz; ++z) {\n"
/*648*/		"		somaErro = 0;\n"
/*649*/		"		for (int i = range.min.x; i <= range.max.x; i++) {\n"
/*650*/		"			for (int j = range.min.y; j <= range.max.y; j++) {\n"
/*651*/		"				testeMax = (entrada[TensorMap(x, y, z, entradatx, entradaty)] ==\n"
/*652*/		"				            saida[TensorMap(i, j, z, saidatx, saidaty)]);\n"
/*653*/		"				somaErro += testeMax * gradNext[TensorMap(i, j, z, saidatx, saidaty)];\n"
/*654*/		"			}\n"
/*655*/		"		}\n"
/*656*/		"		gradEntrada[TensorMap(x, y, z, entradatx, entradaty)] = somaErro;\n"
/*657*/		"	}\n"
/*658*/		"}\n"
/*659*/		"\n"
/*660*/		"\n"
/*661*/		"//poolav.h\n"
/*662*/		"kV PoolAvativa(Vector entrada, Vector saida, int lenFilter,\n"
/*663*/		"               int passo, int saidatx, int saidaty, int entradatx, int entradaty, int k0) {\n"
/*664*/		"	int k = get_global_id(0) + k0;\n"
/*665*/		"	int x, y, z;\n"
/*666*/		"	TensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*667*/		"\n"
/*668*/		"	Ponto3d mapeado = {x * passo, y * passo, 0};\n"
/*669*/		"	double soma = 0, v;\n"
/*670*/		"\n"
/*671*/		"	for (int i = 0; i < lenFilter; ++i) {\n"
/*672*/		"		for (int j = 0; j < lenFilter; ++j) {\n"
/*673*/		"			soma += entrada[TensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*674*/		"\n"
/*675*/		"		}\n"
/*676*/		"	}\n"
/*677*/		"	saida[k] = soma / (lenFilter * lenFilter);\n"
/*678*/		"}\n"
/*679*/		"\n"
/*680*/		"\n"
/*681*/		"kV PoolAvCalcGrads(Vector entrada, Vector gradEntrada, Vector gradNext, Vector saida,\n"
/*682*/		"                   int lenFilter, int passo, int entradatx, int entradaty, int entradatz, int saidatx, int saidaty,\n"
/*683*/		"                   int k0) {\n"
/*684*/		"	int k = get_global_id(0) + k0;\n"
/*685*/		"	int x, y;\n"
/*686*/		"	TensorRemap2D(k, x, y, entradaty)\n"
/*687*/		"	double somaErro = 0;\n"
/*688*/		"	Range range;\n"
/*689*/		"	range = mapeia_entrada_saida(x, y, passo, lenFilter, saidatx, saidaty, 1);\n"
/*690*/		"	for (int z = 0; z < entradatz; ++z) {\n"
/*691*/		"		somaErro = 0;\n"
/*692*/		"		for (int i = range.min.x; i <= range.max.x; i++) {\n"
/*693*/		"			for (int j = range.min.y; j <= range.max.y; j++) {\n"
/*694*/		"				somaErro += gradNext[TensorMap(i, j, z, saidatx, saidaty)];\n"
/*695*/		"			}\n"
/*696*/		"		}\n"
/*697*/		"		gradEntrada[TensorMap(x, y, z, entradatx, entradaty)] = somaErro/ (lenFilter * lenFilter);\n"
/*698*/		"	}\n"
/*699*/		"}\n"
/*700*/		"\n"
/*701*/		"\n"
/*702*/		"//relu.h\n"
/*703*/		"kV reluativa(Vector entrada, Vector saida, int k0) {\n"
/*704*/		"	int k = get_global_id(0) + k0;\n"
/*705*/		"	double v = entrada[k];\n"
/*706*/		"	if (v < 0)\n"
/*707*/		"		v = 0;\n"
/*708*/		"	saida[k] = v;\n"
/*709*/		"}\n"
/*710*/		"\n"
/*711*/		"kV relucalcgrad(Vector gradentrada, Vector entrada, Vector gradnext, int k0) {\n"
/*712*/		"	int k = get_global_id(0) + k0;\n"
/*713*/		"	gradentrada[k] = entrada[k] <= 0.0 ? (0) : gradnext[k];\n"
/*714*/		"}\n"
/*715*/		"\n"
/*716*/		"//softmax.h\n"
/*717*/		"kV SoftMaxativa1(Vector entrada, Vector exponent, Vector soma, int entradatx,\n"
/*718*/		"                 int entradaty,\n"
/*719*/		"                 int k0) {\n"
/*720*/		"	int k = get_global_id(0) + k0;\n"
/*721*/		"	int x, y, z;\n"
/*722*/		"	TensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*723*/		"	exponent[k] = exp(entrada[k]);\n"
/*724*/		"	soma[z] += exponent[k];\n"
/*725*/		"}\n"
/*726*/		"\n"
/*727*/		"kV SoftMaxativa2(Vector exponet, Vector soma, Vector saida,\n"
/*728*/		"                 int saidatx, int saidaty, int k0) {\n"
/*729*/		"	int k = get_global_id(0) + k0;\n"
/*730*/		"	int x, y, z;\n"
/*731*/		"	TensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*732*/		"	saida[k] = exponet[TensorMap(x, y, z, saidatx, saidaty)] / soma[z];\n"
/*733*/		"}\n"
/*734*/		"\n"
/*735*/		"kV softMaxcalcgrad(Vector gradentrada, Vector entrada, Vector gradnext, int k0) {\n"
/*736*/		"	int k = get_global_id(0) + k0;\n"
/*737*/		"	double xi = entrada[k];\n"
/*738*/		"	gradentrada[k] = xi * (1.0 - xi) * gradnext[k];\n"
/*739*/		"}\n"
/*740*/		"\n"
/*741*/		"\n"
;
#endif // KERNELS_H
