//
// Created by Henrique on 14/08/2021.
//
const char __default_kernel__[] = 
/*1*/		"// Created by Xx220xX on 10/05/2020.\n"
/*2*/		"#ifndef ATIVATIONSFUNCTIONS_H\n"
/*3*/		"#define ATIVATIONSFUNCTIONS_H\n"
/*4*/		"#define USEFLOAT 1\n"
/*5*/		"\n"
/*6*/		"#if (USEFLOAT == 1)\n"
/*7*/		"#define    REAL float\n"
/*8*/		"#define    EXP exp\n"
/*9*/		"#define    SQRT sqrt\n"
/*10*/		"#define    REALMAX FLT_MAX\n"
/*11*/		"#define    REALMIN FLT_MIN\n"
/*12*/		"#else\n"
/*13*/		"#define	REALMAX DBL_MAX\n"
/*14*/		"#define	REALMIN DBL_MIN\n"
/*15*/		"#define	REAL double\n"
/*16*/		"#define	EXP exp\n"
/*17*/		"#define	SQRT sqrt\n"
/*18*/		"#endif\n"
/*19*/		"/// memória de  escrita\n"
/*20*/		"#define Vw __global REAL *\n"
/*21*/		"/// memória de leitura\n"
/*22*/		"#define Vr __global REAL *\n"
/*23*/		"/// memória de leitura e ecrita\n"
/*24*/		"#define Vrw __global REAL *\n"
/*25*/		"\n"
/*26*/		"#define kV __kernel void\n"
/*27*/		"\n"
/*28*/		"#define kMap(x, y, z, tx, ty)((z)*(ty*tx)+(x)*ty+(y))\n"
/*29*/		"\n"
/*30*/		"#define kMap4D(x, y, z, l, tx, ty, tz)((l)*(ty)*(tx)*(tz)+(z)*(ty*tx)+(x)*ty+(y))\n"
/*31*/		"\n"
/*32*/		"#define kRep4D(total, _x_, _y_, _z_, _l_, tx, ty, tz)\\\n"
/*33*/		"_y_ = total%ty      ;                                        \\\n"
/*34*/		"_x_ = (total - _y_)%(ty*tx)/ty ;                             \\\n"
/*35*/		"_z_ = (total- _x_*ty - _y_)%(tx*ty*tz)/(ty*tx)  ;            \\\n"
/*36*/		"_l_ = (total -_z_*tx*ty -_x_*ty - _y_)/(tx*ty*tz);\n"
/*37*/		"\n"
/*38*/		"\n"
/*39*/		"#define kRap(total, _x_, _y_, _z_, tx, ty)\\\n"
/*40*/		"_y_ = total % ty;\\\n"
/*41*/		"_x_ = ((total - _y_) % (ty * tx)) / ty;\\\n"
/*42*/		"_z_ = (k - _x_ * ty - _y_) / (tx * ty);\n"
/*43*/		"\n"
/*44*/		"#define KRap2D(total, x, y, ty)\\\n"
/*45*/		"y = total % ty;\\\n"
/*46*/		"x = total/ ty;\n"
/*47*/		"\n"
/*48*/		"typedef struct {\n"
/*49*/		"	int x, y, z;\n"
/*50*/		"} Ponto3d;\n"
/*51*/		"\n"
/*52*/		"typedef struct {\n"
/*53*/		"	Ponto3d min, max;\n"
/*54*/		"} Range;\n"
/*55*/		"\n"
/*56*/		"\n"
/*57*/		"REAL sigmoid(REAL x) {\n"
/*58*/		"	return 1.0 / (1.0 + EXP(-x));\n"
/*59*/		"}\n"
/*60*/		"\n"
/*61*/		"REAL difsigmoid(REAL x) {\n"
/*62*/		"	REAL tmp = sigmoid(x);\n"
/*63*/		"	return tmp * (1.0 - tmp);\n"
/*64*/		"}\n"
/*65*/		"\n"
/*66*/		"REAL tanghG(REAL x) {\n"
/*67*/		"	return tanh(x);\n"
/*68*/		"}\n"
/*69*/		"\n"
/*70*/		"REAL diftanhG(REAL x) {\n"
/*71*/		"	REAL tmp = tanh(x);\n"
/*72*/		"	return (1.0 - tmp * tmp);\n"
/*73*/		"}\n"
/*74*/		"\n"
/*75*/		"REAL relu(REAL x) {\n"
/*76*/		"	return x > 0 ? x : 0.0;\n"
/*77*/		"}\n"
/*78*/		"\n"
/*79*/		"REAL difrelu(REAL x) {\n"
/*80*/		"	return x > 0 ? 1.0 : 0.0;\n"
/*81*/		"}\n"
/*82*/		"\n"
/*83*/		"REAL alan(REAL x) {\n"
/*84*/		"\n"
/*85*/		"	if (x > 1) {\n"
/*86*/		"		return log10(x) + 0.7615941559557649;\n"
/*87*/		"	} else if (x < -1) {\n"
/*88*/		"		return -log10(-x) - 0.7615941559557649;\n"
/*89*/		"	}\n"
/*90*/		"	return tanghG(x);\n"
/*91*/		"}\n"
/*92*/		"\n"
/*93*/		"REAL difalan(REAL x) {\n"
/*94*/		"	if (x > 1) {\n"
/*95*/		"		return 0.419978 / x;\n"
/*96*/		"	} else if (x < 1) {\n"
/*97*/		"		return -0.419978 / x;\n"
/*98*/		"	}\n"
/*99*/		"	return diftanhG(x);\n"
/*100*/		"}\n"
/*101*/		"\n"
/*102*/		"REAL func(unsigned int id, REAL x) {\n"
/*103*/		"	switch (id) {\n"
/*104*/		"		case 0:\n"
/*105*/		"			return sigmoid(x);\n"
/*106*/		"		case 1:\n"
/*107*/		"			return difsigmoid(x);\n"
/*108*/		"		case 2:\n"
/*109*/		"			return tanghG(x);\n"
/*110*/		"		case 3:\n"
/*111*/		"			return diftanhG(x);\n"
/*112*/		"		case 4:\n"
/*113*/		"			return relu(x);\n"
/*114*/		"		case 5:\n"
/*115*/		"			return difrelu(x);\n"
/*116*/		"		case 6:\n"
/*117*/		"			return x;\n"
/*118*/		"		case 7:\n"
/*119*/		"			return 1;\n"
/*120*/		"		case 8:\n"
/*121*/		"			return alan(x);\n"
/*122*/		"		case 9:\n"
/*123*/		"			return difalan(x);\n"
/*124*/		"		default:\n"
/*125*/		"			return 0;\n"
/*126*/		"	}\n"
/*127*/		"}\n"
/*128*/		"\n"
/*129*/		"#endif\n"
/*1*/		"kV BatchNormMedia(Vr a, Vw u, int ax, int ay, int id_0) {\n"
/*2*/		"	int z = get_global_id(0) + id_0;\n"
/*3*/		"	int x, y;\n"
/*4*/		"	REAL m = 0;\n"
/*5*/		"	for (x = 0; x < ax; x++) {\n"
/*6*/		"		for (y = 0; y < ay; y++) {\n"
/*7*/		"			m += a[kMap(x, y, z, ax, ay)];\n"
/*8*/		"		}\n"
/*9*/		"	}\n"
/*10*/		"	u[z] = m / (REAL) (ax * ay);\n"
/*11*/		"}\n"
/*12*/		"\n"
/*13*/		"kV BatchNormInvDesv(Vr a, Vr u, Vr o, REAL episolon, int ax, int ay, int id_0) {\n"
/*14*/		"	int z = get_global_id(0) + id_0;\n"
/*15*/		"	REAL sum = 0;\n"
/*16*/		"	REAL tmp;\n"
/*17*/		"	for (int x = 0; x < ax; x++) {\n"
/*18*/		"		for (int y = 0; y < ay; y++) {\n"
/*19*/		"			tmp = (a[kMap(x, y, z, ax, ay)] - u[z]);\n"
/*20*/		"			sum += tmp * tmp;\n"
/*21*/		"		}\n"
/*22*/		"	}\n"
/*23*/		"	sum = sum / (ax * ay);\n"
/*24*/		"	o[z] = 1.0 / sqrt(sum + episolon);\n"
/*25*/		"}\n"
/*26*/		"\n"
/*27*/		"kV BatchNormNormaliza(Vw s, Vrw v, Vr a, Vr u, Vr o, Vr Y, Vr B, int ax, int ay, int id_0) {\n"
/*28*/		"	int x, y, z;\n"
/*29*/		"	int k = get_global_id(0) + id_0;\n"
/*30*/		"	kRap(k, x, y, z, ax, ay)\n"
/*31*/		"	v[k] = (a[k] - u[z]) * o[z];\n"
/*32*/		"	s[k] = v[k] * Y[z] + B[z];\n"
/*33*/		"}\n"
/*34*/		"\n"
/*35*/		"kV BatchNormaCalcDnorm(Vw dv, Vr ds,Vr Y, int ax, int ay, int id_0) {\n"
/*36*/		"	int x, y, z;\n"
/*37*/		"	int k = get_global_id(0) + id_0;\n"
/*38*/		"	kRap(k, x, y, z, ax, ay)\n"
/*39*/		"	dv[k] = ds[k] * Y[z];\n"
/*40*/		"}\n"
/*41*/		"\n"
/*42*/		"kV BatchNormMediadnorm_norma(Vr v, Vr dv, Vr mdnorm, Vr mdnormnorm, int ax, int ay, int id_0) {\n"
/*43*/		"	int z = get_global_id(0) + id_0;\n"
/*44*/		"	int x, y;\n"
/*45*/		"	REAL md = 0;\n"
/*46*/		"	REAL m = 0;\n"
/*47*/		"	for (x = 0; x < ax; x++) {\n"
/*48*/		"		for (y = 0; y < ay; y++) {\n"
/*49*/		"			m += dv[kMap(x, y, z, ax, ay)];\n"
/*50*/		"			md += (dv[kMap(x, y, z, ax, ay)] * v[kMap(x, y, z, ax, ay)]);\n"
/*51*/		"		}\n"
/*52*/		"	}\n"
/*53*/		"	mdnorm[z] = m / (REAL) (ax * ay);\n"
/*54*/		"	mdnormnorm[z] = md / (REAL) (ax * ay);\n"
/*55*/		"}\n"
/*56*/		"\n"
/*57*/		"kV BatchNormaCalcDa(Vr da, Vr v, Vr dv, Vr mdnorm, Vr mdnormnorm, Vr o, int ax, int ay, int id_0) {\n"
/*58*/		"	int x, y, z;\n"
/*59*/		"	int k = get_global_id(0) + id_0;\n"
/*60*/		"	kRap(k, x, y, z, ax, ay)\n"
/*61*/		"	da[k] = o[z] * (dv[k] - mdnorm[z] - v[k] * mdnormnorm[z]);\n"
/*62*/		"}\n"
/*63*/		"\n"
/*64*/		"kV BatchNormaCalcdYdB(Vr ds, Vr v, Vw dY, Vw dB, long batchSize, int ax, int ay, int id_0) {\n"
/*65*/		"	int z = get_global_id(0) + id_0;\n"
/*66*/		"	REAL sumY = 0;\n"
/*67*/		"	REAL sumB = 0;\n"
/*68*/		"	int k;\n"
/*69*/		"	for (int x = 0; x < ax; ++x) {\n"
/*70*/		"		for (int y = 0; y < ay; ++y) {\n"
/*71*/		"			k = kMap(x, y, z, ax, ay);\n"
/*72*/		"			sumB += ds[k];\n"
/*73*/		"			sumY += ds[k] * v[k];\n"
/*74*/		"		}\n"
/*75*/		"	}\n"
/*76*/		"	dB[z] = dB[z] + sumB / (REAL) batchSize;\n"
/*77*/		"	dY[z] = dY[z] + sumY / (REAL) batchSize;\n"
/*78*/		"}\n"
/*79*/		"\n"
/*80*/		"kV BatchNormaLearn(Vrw Y, Vrw B, Vrw dY, Vrw dB, REAL hit, REAL momento, REAL decaimento, int id_0) {\n"
/*81*/		"	int z = get_global_id(0) + id_0;\n"
/*82*/		"	Y[z] = Y[z] - hit * (dY[z] + Y[z] * decaimento);\n"
/*83*/		"	B[z] = B[z] - hit * (dB[z] + B[z] * decaimento);\n"
/*84*/		"	dY[z] = dY[z] * momento;\n"
/*85*/		"	dB[z] = dB[z] * momento;\n"
/*86*/		"}\n"
/*1*/		"//\n"
/*2*/		"// Created by Henrique on 22-Jul-21.\n"
/*3*/		"//\n"
/*4*/		"\n"
/*5*/		"\n"
/*6*/		"kV createImg(__global unsigned char *out, Vr v, int vx, int vy, int imi, int imy, int k0) {\n"
/*7*/		"	int k = get_global_id(0) + k0;\n"
/*8*/		"	int i, j, z;\n"
/*9*/		"	kRap(k, i, j, z, vx, vy)\n"
/*10*/		"	imi = imi + i;\n"
/*11*/		"	int imj = j + z * vy + z;\n"
/*12*/		"	out[imi * imy + imj] = ((int) v[k]) & 0xff;\n"
/*13*/		"}\n"
/*14*/		"\n"
/*15*/		"kV putIMG(__global unsigned char *imagem_saida, Vr v, int z, REAL px, REAL py, int imy, int width, int i0, int j0, int vx, int vy, int k0) {\n"
/*16*/		"	int k = get_global_id(0) + k0;\n"
/*17*/		"	int i, j;\n"
/*18*/		"	KRap2D(k, i, j, imy)\n"
/*19*/		"	int x = i * px, y = j * py;\n"
/*20*/		"	imagem_saida[(i + i0) * width + j + j0] = ((int) v[kMap(x, y, z, vx, vy)]) & 0xff;\n"
/*21*/		"}\n"
/*22*/		"\n"
/*23*/		"\n"
/*24*/		"kV normalizeVector(Vr input, Vr saida, REAL multiplicador, REAL somador, REAL subtrator, int k0) {\n"
/*25*/		"	int k = get_global_id(0) + k0;\n"
/*26*/		"	saida[k] = (input[k] + somador) * multiplicador - subtrator;\n"
/*27*/		"}\n"
/*28*/		"\n"
/*29*/		"\n"
/*30*/		"kV kernel_sub(Vr ds, Vr s, Vr t, int k0) {\n"
/*31*/		"	int k = get_global_id(0) + k0;\n"
/*32*/		"	ds[k] = s[k] - t[k];\n"
/*33*/		"}\n"
/*34*/		"\n"
/*35*/		"kV kernel_normalizechar2real(Vr dst, __global unsigned char *src, REAL a, REAL b, int k0) {\n"
/*36*/		"	int k = get_global_id(0) + k0;\n"
/*37*/		"//	printf(\"update\\n\");\n"
/*38*/		"	dst[k] = ((REAL) src[k] - b) / a;\n"
/*39*/		"}\n"
/*40*/		"\n"
/*41*/		"kV kernel_getVetorClassFromChar(Vr dst, __global unsigned char *ints, unsigned int noptiobs, int k0) {\n"
/*42*/		"	int w = get_global_id(0) + k0;\n"
/*43*/		"	int y = ints[w];\n"
/*44*/		"	dst[kMap4D(0, y, 0, w, 1, noptiobs, 1)] = 1.0;\n"
/*45*/		"}\n"
/*46*/		"kV kernel_fixW(Vr w, Vr dw, REAL hitlearn, REAL momento, REAL decaimentoDePeso, int k0) {\n"
/*47*/		"	int k = get_global_id(0) + k0;\n"
/*48*/		"	w[k] = w[k] - hitlearn * dw[k] -  hitlearn * w[k] * decaimentoDePeso ;\n"
/*49*/		"	dw[k] = dw[k] * momento;\n"
/*50*/		"}\n"
/*1*/		"#define MAX_INT_DP  ((1UL << 31) - 1)\n"
/*2*/		"\n"
/*3*/		"long randoml(unsigned long seed, unsigned long id) {\n"
/*4*/		"	seed += id;\n"
/*5*/		"	return (seed * 0x5deece66dL + 0xbL) & MAX_INT_DP;\n"
/*6*/		"}\n"
/*7*/		"\n"
/*8*/		"REAL randomD(unsigned long seed, unsigned long id) {\n"
/*9*/		"	return (REAL) randoml(seed, id) / (REAL) MAX_INT_DP;\n"
/*10*/		"}\n"
/*11*/		"\n"
/*12*/		"kV dropativaTreino(Vr entrada, Vw saida, __global char *hitmap, long seed, REAL pativa, int k0) {\n"
/*13*/		"	int i = get_global_id(0) + k0;\n"
/*14*/		"//	printf(\"kernel %lf %lf %g %g\\n\",randomD(seed, i),pativa,(REAL)(seed +i),(REAL)MAX_INT_DP);\n"
/*15*/		"	char teste = (char) (randomD(seed, i) <= pativa);\n"
/*16*/		"	hitmap[i] = teste;\n"
/*17*/		"	saida[i] = teste * entrada[i]/pativa;\n"
/*18*/		"}\n"
/*19*/		"kV dropativaPredict(Vr entrada, Vw saida, REAL pativa, int k0) {\n"
/*20*/		"	int i = get_global_id(0) + k0;\n"
/*21*/		"	saida[i] = entrada[i] ;//* pativa;\n"
/*22*/		"}\n"
/*23*/		"\n"
/*24*/		"kV dropcalcgrad(Vr gradentrada, __global char *hitmap, Vr gradnext, int k0) {\n"
/*25*/		"	int i = get_global_id(0) + k0;\n"
/*26*/		"	gradentrada[i] = hitmap[i] * gradnext[i];\n"
/*27*/		"}\n"
/*1*/		"kV paddingfeed(Vr in, Vr out, unsigned int txi, unsigned int tyi, unsigned int txo, unsigned int tyo, unsigned int t, unsigned int l, int k0) {\n"
/*2*/		"	int k = get_global_id(0) + k0;\n"
/*3*/		"	int x, y, z;\n"
/*4*/		"	kRap(k, x, y, z, txi, tyi)\n"
/*5*/		"	int s = kMap(x + t, y + l, z, txo, tyo);\n"
/*6*/		"	out[s] = in[k];\n"
/*7*/		"}\n"
/*8*/		"\n"
/*9*/		"kV paddingBack(Vr gradNext, Vr gradin, unsigned int txi, unsigned int tyi, unsigned int txo, unsigned int tyo, unsigned int t, unsigned int l, int k0) {\n"
/*10*/		"	int k = get_global_id(0) + k0;\n"
/*11*/		"	int x, y, z;\n"
/*12*/		"	kRap(k, x, y, z, txi, tyi)\n"
/*13*/		"	int s = kMap(x + t, y + l, z, txo, tyo);\n"
/*14*/		"	gradin[k] = gradNext[s];\n"
/*15*/		"}\n"
/*1*/		"kV poolAVativa(Vr entrada, Vr saida, int passox, int passoy, int fx, int fy, int saidatx, int saidaty, int entradatx, int entradaty, int k0) {\n"
/*2*/		"	int k = get_global_id(0) + k0;\n"
/*3*/		"	int x, y, z;\n"
/*4*/		"	kRap(k, x, y, z, saidatx, saidaty)\n"
/*5*/		"\n"
/*6*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*7*/		"	REAL soma = 0;\n"
/*8*/		"\n"
/*9*/		"	for (int i = 0; i < fx; ++i) {\n"
/*10*/		"		for (int j = 0; j < fy; ++j) {\n"
/*11*/		"			soma += entrada[kMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*12*/		"		}\n"
/*13*/		"	}\n"
/*14*/		"	saida[k] = soma / (fx * fy);\n"
/*15*/		"}\n"
/*16*/		"\n"
/*17*/		"\n"
/*18*/		"kV poolAvCalcGrads(Vr A, Vw dA, Vr dS, Vr S, int fx, int fy, int px, int py, int entradatx, int entradaty, int saidatx, int saidaty, int k0) {\n"
/*19*/		"	int k = get_global_id(0) + k0;\n"
/*20*/		"	int x, y, z;\n"
/*21*/		"	kRap(k, x, y, z, entradatx, entradaty)\n"
/*22*/		"	Range range_filtro;\n"
/*23*/		"	range_filtro.min.x = 0;\n"
/*24*/		"	if (x + fx > entradatx) {\n"
/*25*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*26*/		"	}\n"
/*27*/		"	range_filtro.max.x = fx - 1;\n"
/*28*/		"	if (x - fx + 1 < 0) {\n"
/*29*/		"		range_filtro.max.x = x;\n"
/*30*/		"	}\n"
/*31*/		"	range_filtro.min.y = 0;\n"
/*32*/		"	if (y + fy > entradaty) {\n"
/*33*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*34*/		"	}\n"
/*35*/		"	range_filtro.max.y = fy - 1;\n"
/*36*/		"	if (y - fy + 1 < 0) {\n"
/*37*/		"		range_filtro.max.y = y;\n"
/*38*/		"	}\n"
/*39*/		"	int i, j;//saida\n"
/*40*/		"	REAL soma = 0;\n"
/*41*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*42*/		"		i = (x - m) / px;\n"
/*43*/		"		if (i * px + m != x) {\n"
/*44*/		"			continue;\n"
/*45*/		"		}\n"
/*46*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*47*/		"			j = (y - n) / py;\n"
/*48*/		"			if (j * py + n != y) {\n"
/*49*/		"				continue;\n"
/*50*/		"			}\n"
/*51*/		"			soma += dS[kMap(i, j, z, saidatx, saidaty)];\n"
/*52*/		"		}\n"
/*53*/		"	}\n"
/*54*/		"	dA[kMap(x, y, z, entradatx, entradaty)] = soma / (fx * fy);\n"
/*55*/		"\n"
/*56*/		"}\n"
/*57*/		"\n"
/*1*/		"kV poolativa(Vr entrada, Vr saida, int passox, int passoy, int filtrox, int filtroy, int saidatx, int saidaty, int entradatx, int entradaty, int k0) {\n"
/*2*/		"	int k = get_global_id(0) + k0;\n"
/*3*/		"	int x, y, z;\n"
/*4*/		"	kRap(k, x, y, z, saidatx, saidaty)\n"
/*5*/		"\n"
/*6*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*7*/		"	REAL mval, v;\n"
/*8*/		"	mval = -DBL_MAX;\n"
/*9*/		"	for (int i = 0; i < filtrox; ++i) {\n"
/*10*/		"		for (int j = 0; j < filtroy; ++j) {\n"
/*11*/		"			v = entrada[kMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*12*/		"			if (v > mval) {\n"
/*13*/		"				mval = v;\n"
/*14*/		"			}\n"
/*15*/		"		}\n"
/*16*/		"	}\n"
/*17*/		"	saida[k] = mval;\n"
/*18*/		"}\n"
/*19*/		"\n"
/*20*/		"\n"
/*21*/		"kV poolCalcGrads(Vr A, Vr dA, Vr dS, Vr S, int fx, int fy, int px, int py, int entradatx, int entradaty, int saidatx, int saidaty, int k0) {\n"
/*22*/		"	int k = get_global_id(0) + k0;\n"
/*23*/		"	int x, y, z;\n"
/*24*/		"	kRap(k, x, y, z, entradatx, entradaty)\n"
/*25*/		"	Range range_filtro;\n"
/*26*/		"	if (x + fx > entradatx) {\n"
/*27*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*28*/		"	}\n"
/*29*/		"	range_filtro.max.x = fx - 1;\n"
/*30*/		"	if (x - fx + 1 < 0) {\n"
/*31*/		"		range_filtro.max.x = x;\n"
/*32*/		"	}\n"
/*33*/		"	range_filtro.min.y = 0;\n"
/*34*/		"	if (y + fy > entradaty) {\n"
/*35*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*36*/		"	}\n"
/*37*/		"	range_filtro.max.y = fy - 1;\n"
/*38*/		"	if (y - fy + 1 < 0) {\n"
/*39*/		"		range_filtro.max.y = y;\n"
/*40*/		"	}\n"
/*41*/		"	int i, j;//saida\n"
/*42*/		"	REAL soma = 0;\n"
/*43*/		"\n"
/*44*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*45*/		"		i = (x - m) / px;\n"
/*46*/		"		if (i * px + m != x) {\n"
/*47*/		"			continue;\n"
/*48*/		"		}\n"
/*49*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*50*/		"			j = (y - n) / py;\n"
/*51*/		"			if (j * py + n != y) {\n"
/*52*/		"				continue;\n"
/*53*/		"			}\n"
/*54*/		"			if (A[k] == S[kMap(i, j, z, saidatx, saidaty)]) {\n"
/*55*/		"				soma += dS[kMap(i, j, z, saidatx, saidaty)];\n"
/*56*/		"			}\n"
/*57*/		"		}\n"
/*58*/		"	}\n"
/*59*/		"	dA[k] = soma;\n"
/*60*/		"\n"
/*61*/		"}\n"
/*62*/		"\n"
/*1*/		"kV poolativaMin(Vr A, Vr S, int passox, int passoy, int filtrox, int filtroy, int saidatx, int saidaty, int entradatx, int entradaty, int k0) {\n"
/*2*/		"	int k = get_global_id(0) + k0;\n"
/*3*/		"	int x, y, z;\n"
/*4*/		"	kRap(k, x, y, z, saidatx, saidaty)\n"
/*5*/		"\n"
/*6*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*7*/		"	REAL mval, v;\n"
/*8*/		"	mval = DBL_MAX;\n"
/*9*/		"	for (int i = 0; i < filtrox; ++i) {\n"
/*10*/		"		for (int j = 0; j < filtroy; ++j) {\n"
/*11*/		"			v = A[kMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*12*/		"			if (v < mval) {\n"
/*13*/		"				mval = v;\n"
/*14*/		"			}\n"
/*15*/		"		}\n"
/*16*/		"	}\n"
/*17*/		"	S[k] = mval;\n"
/*18*/		"}\n"
/*19*/		"\n"
/*1*/		"kV preluativa(Vr A, Vw S, Vr W, int k0) {\n"
/*2*/		"	int k = get_global_id(0) + k0;\n"
/*3*/		"	REAL v = A[k];\n"
/*4*/		"	if (v < 0) {\n"
/*5*/		"		v = v * W[k];\n"
/*6*/		"	}\n"
/*7*/		"	S[k] = v;\n"
/*8*/		"}\n"
/*9*/		"\n"
/*10*/		"kV prelucalcgrad(Vw dA, Vr A, Vr dS, Vrw W, Vrw dW, int learn, REAL hitlearn, REAL momento, REAL decaimento, int k0) {\n"
/*11*/		"	int k = get_global_id(0) + k0;\n"
/*12*/		"	REAL v = A[k];\n"
/*13*/		"	if (v < 0) {\n"
/*14*/		"		dA[k] = dS[k] * W[k];\n"
/*15*/		"		dW[k] = dS[k] + momento * dW[k];\n"
/*16*/		"	} else {\n"
/*17*/		"		dA[k] = dS[k];\n"
/*18*/		"		dW[k] = momento * dW[k];\n"
/*19*/		"	}\n"
/*20*/		"	if (learn) {\n"
/*21*/		"		W[k] = W[k] - hitlearn * (dW[k] + W[k] * decaimento);\n"
/*22*/		"	}\n"
/*23*/		"}\n"
/*24*/		"\n"
/*25*/		"kV preluonlyfix(Vr A, Vr dS, Vrw W, Vrw dW, REAL hitlearn, REAL momento, REAL decaimento, int k0) {\n"
/*26*/		"	int k = get_global_id(0) + k0;\n"
/*27*/		"	REAL v = A[k];\n"
/*28*/		"	if (v < 0) {\n"
/*29*/		"		dW[k] = dS[k] + momento * dW[k];\n"
/*30*/		"	} else {\n"
/*31*/		"		dW[k] = momento * dW[k];\n"
/*32*/		"	}\n"
/*33*/		"	W[k] = W[k] - hitlearn * (dW[k] + W[k] * decaimento);\n"
/*34*/		"}\n"
/*35*/		"\n"
/*36*/		"kV prelucalcgradBatch(Vw dA, Vr A, Vr dS, Vr W, Vrw dW, long batchSize, int k0) {\n"
/*37*/		"	int k = get_global_id(0) + k0;\n"
/*38*/		"	REAL v = A[k];\n"
/*39*/		"	if (v < 0) {\n"
/*40*/		"		dA[k] = dS[k] * W[k];\n"
/*41*/		"		dW[k] = dS[k] / batchSize + dW[k];\n"
/*42*/		"	} else {\n"
/*43*/		"		dA[k] = dS[k];\n"
/*44*/		"		dW[k] = 1.0 / batchSize + dW[k];\n"
/*45*/		"	}\n"
/*46*/		"}\n"
/*47*/		"\n"
/*48*/		"kV preluonlyDABatch(Vr A, Vr dS, Vr W, Vr dW, long batchSize, int k0) {\n"
/*49*/		"	int k = get_global_id(0) + k0;\n"
/*50*/		"	REAL v = A[k];\n"
/*51*/		"	if (v < 0) {\n"
/*52*/		"		dW[k] = dS[k] / batchSize + dW[k];\n"
/*53*/		"	} else {\n"
/*54*/		"		dW[k] = 1.0 / batchSize + dW[k];\n"
/*55*/		"	}\n"
/*56*/		"}\n"
/*1*/		"\n"
/*2*/		"kV reluativa(Vr A, Vr S, REAL menor, REAL maior, int k0) {\n"
/*3*/		"	int k = get_global_id(0) + k0;\n"
/*4*/		"	S[k] = A[k] < 0.0 ? (A[k] * menor) : (A[k] * maior);\n"
/*5*/		"}\n"
/*6*/		"\n"
/*7*/		"\n"
/*8*/		"kV relucalcgrad(Vr dA, Vr A, Vr dS, REAL menor, REAL maior, int k0) {\n"
/*9*/		"	int k = get_global_id(0) + k0;\n"
/*10*/		"	dA[k] = A[k] < 0.0 ? (menor * dS[k]) : (maior * dS[k]);\n"
/*11*/		"}\n"
/*1*/		"/**\n"
/*2*/		" * @goal calcular e^a(x,y,z)\n"
/*3*/		" * @iteration dimensão de a (x,y,z)\n"
/*4*/		" * @param entrada Tensor de entrada (leitura)\n"
/*5*/		" * @param exponent Tensor e^entrada (escrita)\n"
/*6*/		" * @param k0 usado internamente no kernel\n"
/*7*/		" */\n"
/*8*/		"kV softmaxExp(Vr entrada, Vr exponent, int k0) {\n"
/*9*/		"	int k = get_global_id(0) + k0;\n"
/*10*/		"	exponent[k] = EXP(entrada[k]);\n"
/*11*/		"}\n"
/*12*/		"\n"
/*13*/		"/***\n"
/*14*/		" * @goal encontrar a soma de cada dimensão z\n"
/*15*/		" * @iteration dimensão z da entrada a(:,:,z)\n"
/*16*/		" * @param eps Tensor exponencial da entrada (leitura)\n"
/*17*/		" * @param soma Tensor da soma das exponenciais (escrita)\n"
/*18*/		" * @param saidatx dimensão x da saída\n"
/*19*/		" * @param saidaty dimensão x da saída\n"
/*20*/		" * @param k0 usado internamente no kernel\n"
/*21*/		" */\n"
/*22*/		"kV softmaxSomaExp(Vr eps, Vr soma, int saidatx, int saidaty, int k0) {\n"
/*23*/		"	int z = get_global_id(0) + k0;\n"
/*24*/		"	int x, y;\n"
/*25*/		"	REAL sum = 0;\n"
/*26*/		"	for (x = 0; x < saidatx; x++) {\n"
/*27*/		"		for (y = 0; y < saidaty; y++) {\n"
/*28*/		"			sum += eps[kMap(x, y, z, saidatx, saidaty)];\n"
/*29*/		"		}\n"
/*30*/		"	}\n"
/*31*/		"	soma[z] = sum;\n"
/*32*/		"}\n"
/*33*/		"/***\n"
/*34*/		" * @goal Normalizar a exponencial pela soma\n"
/*35*/		" *  * @iteration dimensão da saída  s(x,y,z)\n"
/*36*/		" * @param exponet Tensor exponencial da entrada (leitura)\n"
/*37*/		" * @param soma Tensor da soma das exponenciais (leitura)\n"
/*38*/		" * @param saida Tensor de saída (escrita)\n"
/*39*/		" * @param saidatx dimensão x da saída\n"
/*40*/		" * @param saidaty dimensão x da saída\n"
/*41*/		" * @param k0 usado internamente no kernel\n"
/*42*/		" */\n"
/*43*/		"kV softmaxNormaliza(Vr exponet, Vr soma, Vr saida, int saidatx, int saidaty, int k0) {\n"
/*44*/		"	int k = get_global_id(0) + k0;\n"
/*45*/		"	int x, y, z;\n"
/*46*/		"	kRap(k, x, y, z, saidatx, saidaty)\n"
/*47*/		"	saida[k] = exponet[k] / soma[z];\n"
/*48*/		"}\n"
/*49*/		"/**\n"
/*50*/		" * @goal Calcular os gradientes de entrada\n"
/*51*/		" * @iteration dimensão da entrada a(x,y,z)\n"
/*52*/		" * @param da Tensor de gradientes de entrada (escrita)\n"
/*53*/		" * @param s Tensor de saida (leitura)\n"
/*54*/		" * @param ds Tensor gradiente da saída (leitura)\n"
/*55*/		" * @param sx dimensão x da saída\n"
/*56*/		" * @param sy dimensão y da saída\n"
/*57*/		" * @param k0 usado internamente no kernel\n"
/*58*/		" */\n"
/*59*/		"kV softMaxcalcgrad(Vr da, Vr s, Vr ds, int sx, int sy, int k0) {\n"
/*60*/		"	int k = get_global_id(0) + k0;\n"
/*61*/		"	int i, z, j;\n"
/*62*/		"	int sxy = sx * sy;\n"
/*63*/		"	KRap2D(k, z, i, sxy);\n"
/*64*/		"	REAL yi = s[k];\n"
/*65*/		"	REAL soma = 0.0;\n"
/*66*/		"	for (j = 0; j < sxy; ++j) {\n"
/*67*/		"		if (j == i) {\n"
/*68*/		"			soma += yi * (1 - yi) * ds[j + z * sxy];\n"
/*69*/		"//			printf(\"v(%d,%d,%d) =  %f, %f %f;\\n\", i+1, j+1, z+1, yi * (1 - yi),s[j + z * sxy],yi);\n"
/*70*/		"		} else {\n"
/*71*/		"			soma += -yi * s[j + z * sxy] * ds[j + z * sxy];\n"
/*72*/		"//			printf(\"v(%d,%d,%d) =  %f, %f %f;\\n\", i+1, j+1, z+1, yi * -s[j + z * sxy],s[j + z * sxy],yi);\n"
/*73*/		"		}\n"
/*74*/		"	}\n"
/*75*/		"	da[k] = soma;\n"
/*76*/		"}\n"
/*77*/		"\n"
/*78*/		"/**\n"
/*79*/		" * @goal Encontrar o maximo e o indice de cada dimensão z\n"
/*80*/		" * @iteration dimensão z da entrada a(:,:,z)\n"
/*81*/		" * @param a entrada\n"
/*82*/		" * @param mx tensor maximos\n"
/*83*/		" * @param i_max tensor indice de maximos\n"
/*84*/		" * @param ax entrada x\n"
/*85*/		" * @param ay entrada y\n"
/*86*/		" * @param k0 uso interno no kernel\n"
/*87*/		" */\n"
/*88*/		"kV softmaxFindMax(Vr a, Vr mx, __global int *i_max, int ax, int ay, int k0) {\n"
/*89*/		"	int z = get_global_id(0) + k0;\n"
/*90*/		"	int x, y;\n"
/*91*/		"	REAL maximo = a[kMap(0, 0, z, ax, ay)];\n"
/*92*/		"	REAL adata;\n"
/*93*/		"	int imax = 0;\n"
/*94*/		"	for (x = 0; x < ax; x++) {\n"
/*95*/		"		for (y = 0; y < ay; y++) {\n"
/*96*/		"			adata = a[kMap(x, y, z, ax, ay)];\n"
/*97*/		"			if (maximo < adata) {\n"
/*98*/		"				maximo = adata;\n"
/*99*/		"				imax = x * ay + y;\n"
/*100*/		"			}\n"
/*101*/		"		}\n"
/*102*/		"	}\n"
/*103*/		"	i_max[z] = imax;\n"
/*104*/		"	mx[z] = maximo;\n"
/*105*/		"}\n"
/*106*/		"\n"
/*107*/		"/**\n"
/*108*/		" * @goal calcular e^(a(x,y,z) - max(a))\n"
/*109*/		" * @iteration dimensão de a (x,y,z)\n"
/*110*/		" * @param entrada Tensor de entrada (leitura)\n"
/*111*/		" * @param exponent Tensor e^entrada (escrita)\n"
/*112*/		" * @param mx tensor maximos\n"
/*113*/		" * @param ax entrada x\n"
/*114*/		" * @param ay entrada y\n"
/*115*/		" * @param k0 usado internamente no kernel\n"
/*116*/		" */\n"
/*117*/		"kV softmaxExpNorm(Vr entrada, Vr exponent, Vr mx, int ax, int ay, int k0) {\n"
/*118*/		"	int k = get_global_id(0) + k0;\n"
/*119*/		"	int x, y, z;\n"
/*120*/		"	kRap(k, x, y, z, ax, ay);\n"
/*121*/		"	exponent[k] = EXP(entrada[k] - mx[z]);\n"
/*122*/		"}\n"
;
