//
// Created by Henrique on 14/08/2021.
//
const char __default_kernel__[] = 
/*1*/		"#ifndef GAB_KERNELS_OPENCL_H\n"
/*2*/		"#define GAB_KERNELS_OPENCL_H\n"
/*3*/		"//utils.h\n"
/*4*/		"// Created by Xx220xX on 10/05/2020.\n"
/*5*/		"#ifndef ATIVATIONSFUNCTIONS_H\n"
/*6*/		"#define ATIVATIONSFUNCTIONS_H\n"
/*7*/		"#define USEFLOAT 1\n"
/*8*/		"\n"
/*9*/		"#if (USEFLOAT == 1)\n"
/*10*/		"#define    REAL float\n"
/*11*/		"#define    TANH tanh\n"
/*12*/		"#define    EXP exp\n"
/*13*/		"#define    SQRT sqrt\n"
/*14*/		"#define    REALMAX FLT_MAX\n"
/*15*/		"#define    REALMIN FLT_MIN\n"
/*16*/		"#else\n"
/*17*/		"#define	REALMAX DBL_MAX\n"
/*18*/		"#define	REALMIN DBL_MIN\n"
/*19*/		"#define	REAL double\n"
/*20*/		"#define	TANH tanh\n"
/*21*/		"#define	EXP exp\n"
/*22*/		"#define	SQRT sqrt\n"
/*23*/		"#endif\n"
/*24*/		"#define Vector __global REAL *\n"
/*25*/		"\n"
/*26*/		"#define kV __kernel void\n"
/*27*/		"\n"
/*28*/		"#define KTensorMap(x, y, z, tx, ty)((z)*(ty*tx)+(x)*ty+(y))\n"
/*29*/		"\n"
/*30*/		"#define KTensorMap4D(x, y, z, l, tx, ty, tz)((l)*(ty)*(tx)*(tz)+(z)*(ty*tx)+(x)*ty+(y))\n"
/*31*/		"\n"
/*32*/		"#define KTensorRemap4D(total, _x_, _y_, _z_, _l_, tx, ty, tz)\\\n"
/*33*/		"_y_ = total%ty      ;                                        \\\n"
/*34*/		"_x_ = (total - _y_)%(ty*tx)/ty ;                             \\\n"
/*35*/		"_z_ = (total- _x_*ty - _y_)%(tx*ty*tz)/(ty*tx)  ;            \\\n"
/*36*/		"_l_ = (total -_z_*tx*ty -_x_*ty - _y_)/(tx*ty*tz);\n"
/*37*/		"\n"
/*38*/		"\n"
/*39*/		"#define KTensorRemap(total, _x_, _y_, _z_, tx, ty)\\\n"
/*40*/		"_y_ = total % ty;\\\n"
/*41*/		"_x_ = ((total - _y_) % (ty * tx)) / ty;\\\n"
/*42*/		"_z_ = (k - _x_ * ty - _y_) / (tx * ty);\n"
/*43*/		"\n"
/*44*/		"#define KTensorRemap2D(total, x, y, ty)\\\n"
/*45*/		"y = total % ty;\\\n"
/*46*/		"x = total/ ty;\n"
/*47*/		"\n"
/*48*/		"typedef struct {\n"
/*49*/		"	int x, y, z;\n"
/*50*/		"} Ponto3d;\n"
/*51*/		"\n"
/*52*/		"typedef struct {\n"
/*53*/		"	Ponto3d min, max;\n"
/*54*/		"} Range;\n"
/*55*/		"\n"
/*56*/		"\n"
/*57*/		"REAL sigmoid(REAL x) {\n"
/*58*/		"	return 1.0 / (1.0 + EXP(-x));\n"
/*59*/		"}\n"
/*60*/		"\n"
/*61*/		"REAL difsigmoid(REAL x) {\n"
/*62*/		"	REAL tmp = sigmoid(x);\n"
/*63*/		"	return tmp * (1.0 - tmp);\n"
/*64*/		"}\n"
/*65*/		"\n"
/*66*/		"REAL tanghG(REAL x) {\n"
/*67*/		"	return TANH(x);\n"
/*68*/		"}\n"
/*69*/		"\n"
/*70*/		"REAL diftanhG(REAL x) {\n"
/*71*/		"	REAL tmp = TANH(x);\n"
/*72*/		"	return (1.0 - tmp * tmp);\n"
/*73*/		"}\n"
/*74*/		"\n"
/*75*/		"REAL relu(REAL x) {\n"
/*76*/		"	return x > 0 ? x : 0.0;\n"
/*77*/		"}\n"
/*78*/		"\n"
/*79*/		"REAL difrelu(REAL x) {\n"
/*80*/		"	return x > 0 ? 1.0 : 0.0;\n"
/*81*/		"}\n"
/*82*/		"\n"
/*83*/		"REAL alan(REAL x) {\n"
/*84*/		"	if (x > 1) {\n"
/*85*/		"		return log10(x) + 0.7615941559557649;\n"
/*86*/		"	} else if (x < -1) {\n"
/*87*/		"		return -log10(-x) - 0.7615941559557649;\n"
/*88*/		"	}\n"
/*89*/		"	return tanghG(x);\n"
/*90*/		"}\n"
/*91*/		"\n"
/*92*/		"REAL difalan(REAL x) {\n"
/*93*/		"	if (x > 1) {\n"
/*94*/		"		return 0.419978 / x;\n"
/*95*/		"	} else if (x < 1) {\n"
/*96*/		"		return -0.419978 / x;\n"
/*97*/		"	}\n"
/*98*/		"	return diftanhG(x);\n"
/*99*/		"}\n"
/*100*/		"\n"
/*101*/		"REAL func(unsigned int id, REAL x) {\n"
/*102*/		"	switch (id) {\n"
/*103*/		"		case 0:\n"
/*104*/		"			return sigmoid(x);\n"
/*105*/		"		case 1:\n"
/*106*/		"			return difsigmoid(x);\n"
/*107*/		"		case 2:\n"
/*108*/		"			return tanghG(x);\n"
/*109*/		"		case 3:\n"
/*110*/		"			return diftanhG(x);\n"
/*111*/		"		case 4:\n"
/*112*/		"			return relu(x);\n"
/*113*/		"		case 5:\n"
/*114*/		"			return difrelu(x);\n"
/*115*/		"		case 6:\n"
/*116*/		"			return x;\n"
/*117*/		"		case 7:\n"
/*118*/		"			return 1;\n"
/*119*/		"		case 8:\n"
/*120*/		"			return alan(x);\n"
/*121*/		"		case 9:\n"
/*122*/		"			return difalan(x);\n"
/*123*/		"		default:\n"
/*124*/		"			return 0;\n"
/*125*/		"	}\n"
/*126*/		"}\n"
/*127*/		"\n"
/*128*/		"#endif\n"
/*129*/		"//bathnorm.h\n"
/*130*/		"/// achar a media\n"
/*131*/		"/// ativa 1\n"
/*132*/		"kV BatchNormMedia(Vector entrada, Vector media, int entradatx, int entradaty, int k0) {\n"
/*133*/		"	int z = get_global_id(0) + k0;\n"
/*134*/		"	int x, y;\n"
/*135*/		"	REAL m = 0;\n"
/*136*/		"	for (x = 0; x < entradatx; x++) {\n"
/*137*/		"		for (y = 0; y < entradaty; y++) {\n"
/*138*/		"			m += entrada[KTensorMap(x, y, z, entradatx, entradaty)];\n"
/*139*/		"		}\n"
/*140*/		"	}\n"
/*141*/		"	media[z] = m / (REAL) (entradatx * entradaty);\n"
/*142*/		"}\n"
/*143*/		"\n"
/*144*/		"kV BatchNormInvDesv(Vector a, Vector media, Vector inv_desv, REAL episolon, int ax, int ay, int k0) {\n"
/*145*/		"	int z = get_global_id(0) + k0;\n"
/*146*/		"	REAL sum = 0;\n"
/*147*/		"	REAL tmp;\n"
/*148*/		"	for (int x = 0; x < ax; x++) {\n"
/*149*/		"		for (int y = 0; y < ay; y++) {\n"
/*150*/		"			tmp = (a[KTensorMap(x, y, z, ax, ay)] - media[z]);\n"
/*151*/		"			sum += tmp * tmp;\n"
/*152*/		"		}\n"
/*153*/		"	}\n"
/*154*/		"	sum = sum / (ax * ay);\n"
/*155*/		"	inv_desv[z] = 1.0 / sqrt(sum + episolon);\n"
/*156*/		"}\n"
/*157*/		"\n"
/*158*/		"kV BatchNormNormaliza(Vector saida, Vector norma, Vector a, Vector media, Vector inv_std, Vector Y, Vector B, int ax, int ay, int k0) {\n"
/*159*/		"	int x, y, z;\n"
/*160*/		"	int k = get_global_id(0) + k0;\n"
/*161*/		"	KTensorRemap(k, x, y, z, ax, ay)\n"
/*162*/		"	norma[k] = (a[k] - media[z]) * inv_std[z];\n"
/*163*/		"	saida[k] = norma[k] * Y[z] + B[z];\n"
/*164*/		"}\n"
/*165*/		"\n"
/*166*/		"kV BatchNormaCalcDnorm(Vector dnorm, Vector ds, Vector Y, int ax, int ay, int k0) {\n"
/*167*/		"	int x, y, z;\n"
/*168*/		"	int k = get_global_id(0) + k0;\n"
/*169*/		"	KTensorRemap(k, x, y, z, ax, ay)\n"
/*170*/		"	dnorm[k] = ds[k] * Y[z];\n"
/*171*/		"}\n"
/*172*/		"\n"
/*173*/		"kV BatchNormMediadnorm_norma(Vector norm, Vector dnorm, Vector mdnorm, Vector mdnormnorm, int ax, int ay, int k0) {\n"
/*174*/		"	int z = get_global_id(0) + k0;\n"
/*175*/		"	int x, y;\n"
/*176*/		"	REAL md = 0;\n"
/*177*/		"	REAL m = 0;\n"
/*178*/		"	REAL tmp;\n"
/*179*/		"	for (x = 0; x < ax; x++) {\n"
/*180*/		"		for (y = 0; y < ay; y++) {\n"
/*181*/		"			m += dnorm[KTensorMap(x, y, z, ax, ay)];\n"
/*182*/		"			md += (dnorm[KTensorMap(x, y, z, ax, ay)] * norm[KTensorMap(x, y, z, ax, ay)]);\n"
/*183*/		"		}\n"
/*184*/		"	}\n"
/*185*/		"	mdnorm[z] = m / (REAL) (ax * ay);\n"
/*186*/		"	mdnormnorm[z] = md / (REAL) (ax * ay);\n"
/*187*/		"}\n"
/*188*/		"\n"
/*189*/		"kV BatchNormaCalcDa(Vector da, Vector norm, Vector dnorm, Vector mdnorm, Vector mdnormnorm, Vector inv_std, int ax, int ay, int k0) {\n"
/*190*/		"	int x, y, z;\n"
/*191*/		"	int k = get_global_id(0) + k0;\n"
/*192*/		"	KTensorRemap(k, x, y, z, ax, ay)\n"
/*193*/		"	da[k] = inv_std[z] * (dnorm[k] - mdnorm[z] - norm[k] * mdnormnorm[z]);\n"
/*194*/		"}\n"
/*195*/		"\n"
/*196*/		"\n"
/*197*/		"kV BatchNormaCalcdYdB(Vector ds, Vector norma, Vector gradY, Vector gradB, long batchSize, int ax, int ay, int k0) {\n"
/*198*/		"	int z = get_global_id(0) + k0;\n"
/*199*/		"	REAL sumY = 0;\n"
/*200*/		"	REAL sumB = 0;\n"
/*201*/		"	int k;\n"
/*202*/		"	for (int x = 0; x < ax; ++x) {\n"
/*203*/		"		for (int y = 0; y < ay; ++y) {\n"
/*204*/		"			k = KTensorMap(x, y, z, ax, ay);\n"
/*205*/		"			sumB += ds[k];\n"
/*206*/		"			sumY += ds[k] * norma[k];\n"
/*207*/		"		}\n"
/*208*/		"	}\n"
/*209*/		"//	printf(\"%d %f %f\\n\",z,gradB[z],gradY[z]);\n"
/*210*/		"	gradB[z] = gradB[z] + sumB / (REAL) batchSize;\n"
/*211*/		"	gradY[z] = gradY[z] + sumY / (REAL) batchSize;\n"
/*212*/		"}\n"
/*213*/		"\n"
/*214*/		"kV BatchNormaLearn(Vector Y, Vector B, Vector gradY, Vector gradB, REAL hit, REAL momento, REAL decaimento, int k0) {\n"
/*215*/		"	int z = get_global_id(0) + k0;\n"
/*216*/		"	Y[z] = Y[z] - hit * (gradY[z] + Y[z] * decaimento);\n"
/*217*/		"	B[z] = B[z] - hit * (gradB[z] + B[z] * decaimento);\n"
/*218*/		"\n"
/*219*/		"	gradY[z] = gradY[z] * momento;\n"
/*220*/		"	gradB[z] = gradB[z] * momento;\n"
/*221*/		"}\n"
/*222*/		"\n"
/*223*/		"\n"
/*224*/		"\n"
/*225*/		"//cnnutils.h\n"
/*226*/		"//\n"
/*227*/		"// Created by Henrique on 22-Jul-21.\n"
/*228*/		"//\n"
/*229*/		"\n"
/*230*/		"\n"
/*231*/		"kV createImg(__global unsigned char *out, Vector v, int vx, int vy, int imi, int imy, int k0) {\n"
/*232*/		"	int k = get_global_id(0) + k0;\n"
/*233*/		"	int i, j, z;\n"
/*234*/		"	KTensorRemap(k, i, j, z, vx, vy)\n"
/*235*/		"	imi = imi + i;\n"
/*236*/		"	int imj = j + z * vy + z;\n"
/*237*/		"	out[imi * imy + imj] = ((int) v[k]) & 0xff;\n"
/*238*/		"}\n"
/*239*/		"\n"
/*240*/		"kV putIMG(__global unsigned char *imagem_saida,\n"
/*241*/		"		  Vector v,\n"
/*242*/		"		  int z,\n"
/*243*/		"		  REAL px,\n"
/*244*/		"		  REAL py,\n"
/*245*/		"		  int imy,\n"
/*246*/		"		  int width,\n"
/*247*/		"		  int i0,\n"
/*248*/		"		  int j0,\n"
/*249*/		"		  int vx,\n"
/*250*/		"		  int vy,\n"
/*251*/		"		  int k0) {\n"
/*252*/		"	int k = get_global_id(0) + k0;\n"
/*253*/		"	int i, j;\n"
/*254*/		"	KTensorRemap2D(k, i, j, imy)\n"
/*255*/		"	int x = i * px, y = j * py;\n"
/*256*/		"	imagem_saida[(i + i0) * width + j + j0] = ((int) v[KTensorMap(x, y, z, vx, vy)]) & 0xff;\n"
/*257*/		"}\n"
/*258*/		"\n"
/*259*/		"\n"
/*260*/		"kV normalizeVector(Vector input, Vector saida, REAL multiplicador, REAL somador, REAL subtrator,\n"
/*261*/		"				   int k0) {\n"
/*262*/		"	int k = get_global_id(0) + k0;\n"
/*263*/		"	saida[k] = (input[k] + somador) * multiplicador - subtrator;\n"
/*264*/		"}\n"
/*265*/		"\n"
/*266*/		"\n"
/*267*/		"kV kernel_sub(Vector ds, Vector s, Vector t, int k0) {\n"
/*268*/		"	int k = get_global_id(0) + k0;\n"
/*269*/		"	ds[k] = s[k] - t[k];\n"
/*270*/		"}\n"
/*271*/		"\n"
/*272*/		"kV kernel_normalizechar2real(Vector dst, __global unsigned char *src, REAL a, REAL b, int k0) {\n"
/*273*/		"	int k = get_global_id(0) + k0;\n"
/*274*/		"//	printf(\"update\\n\");\n"
/*275*/		"	dst[k] = ((REAL)src[k] - b) / a;\n"
/*276*/		"}\n"
/*277*/		"\n"
/*278*/		"kV kernel_getVetorClassFromChar( Vector dst, __global unsigned char *ints,unsigned int noptiobs, int k0) {\n"
/*279*/		"	int w = get_global_id(0) + k0;\n"
/*280*/		"	int y = ints[w];\n"
/*281*/		"	dst[KTensorMap4D(0, y, 0, w, 1, noptiobs, 1)] = 1.0;\n"
/*282*/		"}\n"
/*283*/		"\n"
/*284*/		"//conv.h\n"
/*285*/		"kV convSum(Vector filtro, Vector entrada, Vector saida,\n"
/*286*/		"           int passox, int passoy,\n"
/*287*/		"           int saidatx, int saidaty,\n"
/*288*/		"           int entradatx, int entradaty,\n"
/*289*/		"           int fx, int fy, int fz, int k0) {\n"
/*290*/		"	int k = get_global_id(0) + k0;\n"
/*291*/		"	int x, y, filtrok;\n"
/*292*/		"	KTensorRemap(k, x, y, filtrok, saidatx, saidaty)\n"
/*293*/		"	REAL sum = 0, f = 0, v = 0;\n"
/*294*/		"	int lf = 0, le = 0;\n"
/*295*/		"	for (int m = 0; m < fx; m++) {\n"
/*296*/		"		for (int n = 0; n < fy; n++) {\n"
/*297*/		"			for (int z = 0; z < fz; z++) {\n"
/*298*/		"				lf = KTensorMap4D(m, n, z, filtrok, fx, fy, fz);\n"
/*299*/		"				le = KTensorMap(x * passox + m, y * passoy + n, z, entradatx, entradaty);\n"
/*300*/		"				f = filtro[lf];\n"
/*301*/		"				v = entrada[le];\n"
/*302*/		"				sum += f * v;\n"
/*303*/		"			}\n"
/*304*/		"		}\n"
/*305*/		"	}\n"
/*306*/		"	saida[k] = sum;\n"
/*307*/		"}\n"
/*308*/		"\n"
/*309*/		"\n"
/*310*/		"kV convCalcGradAndFixWeight(Vector filtros, Vector ds,\n"
/*311*/		"                            Vector entrada, Vector gradFiltro,\n"
/*312*/		"                            int fx, int fy, int fz,\n"
/*313*/		"                            int entrada_tx, int entrada_ty,\n"
/*314*/		"                            int saida_tx, int saida_ty,\n"
/*315*/		"                            int passox, int passoy,\n"
/*316*/		"                            REAL hitLearn, REAL momento, REAL weightDecay,\n"
/*317*/		"                            int k0) {\n"
/*318*/		"	int k = get_global_id(0) + k0;\n"
/*319*/		"	int m, n, z, l;\n"
/*320*/		"	KTensorRemap4D(k, m, n, z, l, fx, fy, fz)\n"
/*321*/		"	REAL soma = 0;\n"
/*322*/		"	int le, ls;\n"
/*323*/		"	for (int i = 0; i < saida_tx; ++i) {\n"
/*324*/		"		for (int j = 0; j < saida_ty; ++j) {\n"
/*325*/		"			le = KTensorMap(i * passox + m, j * passoy + n, z, entrada_tx, entrada_ty);\n"
/*326*/		"			ls = KTensorMap(i, j, l, saida_tx, saida_ty);\n"
/*327*/		"			soma += entrada[le]\n"
/*328*/		"			        * ds[ls];\n"
/*329*/		"		}\n"
/*330*/		"	}\n"
/*331*/		"	REAL dw = soma + gradFiltro[k] * momento;\n"
/*332*/		"	REAL w = filtros[k];\n"
/*333*/		"	filtros[k] = w - hitLearn * (dw + w * weightDecay);\n"
/*334*/		"	gradFiltro[k] = dw;\n"
/*335*/		"}\n"
/*336*/		"\n"
/*337*/		"kV convCalcGradIn(Vector filtro, Vector gradEntrada, Vector gradNext,\n"
/*338*/		"                  int fx, int fy, int fz,\n"
/*339*/		"                  int passox, int passoy,\n"
/*340*/		"                  int entradatx, int entradaty,\n"
/*341*/		"                  int saidatx, int saidaty, int saidatz,\n"
/*342*/		"                  int k0) {\n"
/*343*/		"	int k = get_global_id(0) + k0;\n"
/*344*/		"	int x, y, z;\n"
/*345*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*346*/		"\n"
/*347*/		"	Range range_filtro;\n"
/*348*/		"	range_filtro.min.x = 0;\n"
/*349*/		"	if (x + fx > entradatx) {\n"
/*350*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*351*/		"	}\n"
/*352*/		"	range_filtro.max.x = fx - 1;\n"
/*353*/		"	if (x - fx + 1 < 0) {\n"
/*354*/		"		range_filtro.max.x = x;\n"
/*355*/		"	}\n"
/*356*/		"	range_filtro.min.y = 0;\n"
/*357*/		"	if (y + fy > entradaty) {\n"
/*358*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*359*/		"	}\n"
/*360*/		"	range_filtro.max.y = fy - 1;\n"
/*361*/		"	if (y - fy + 1 < 0) {\n"
/*362*/		"		range_filtro.max.y = y;\n"
/*363*/		"	}\n"
/*364*/		"	REAL somaErro = 0, pesoAplicado = 0;\n"
/*365*/		"	int i, j;\n"
/*366*/		"	int lf, ls;\n"
/*367*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*368*/		"		i = (x - m) / passox;\n"
/*369*/		"		if (i * passox + m != x) continue;\n"
/*370*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*371*/		"			j = (y - n) / passoy;\n"
/*372*/		"			if (j * passoy + n != y) continue;\n"
/*373*/		"			for (int w = 0; w < saidatz; w++) {\n"
/*374*/		"				lf = KTensorMap4D(m, n, z, w, fx, fy, fz);\n"
/*375*/		"				ls = KTensorMap(i, j, w, saidatx, saidaty);\n"
/*376*/		"				pesoAplicado = filtro[lf];\n"
/*377*/		"				somaErro += pesoAplicado * gradNext[ls];\n"
/*378*/		"			}\n"
/*379*/		"		}\n"
/*380*/		"	}\n"
/*381*/		"	gradEntrada[k] = somaErro;\n"
/*382*/		"}\n"
/*383*/		"\n"
/*384*/		"\n"
/*385*/		"//convf.h\n"
/*386*/		"kV convFSum(Vector filtro, Vector entrada, Vector Z, Vector saida,\n"
/*387*/		"			int passox, int passoy,\n"
/*388*/		"			int saidatx, int saidaty,\n"
/*389*/		"			int entradatx, int entradaty,\n"
/*390*/		"			int fx, int fy, int fz, int fid, int k0) {\n"
/*391*/		"	int k = get_global_id(0) + k0;\n"
/*392*/		"	int x, y, filtrok;\n"
/*393*/		"\n"
/*394*/		"	KTensorRemap(k, x, y, filtrok, saidatx, saidaty)\n"
/*395*/		"	REAL sum = 0, f, v;\n"
/*396*/		"	int lf, le;\n"
/*397*/		"	for (int m = 0; m < fx; m++) {\n"
/*398*/		"		for (int n = 0; n < fy; n++) {\n"
/*399*/		"			for (int z = 0; z < fz; z++) {\n"
/*400*/		"				lf = KTensorMap4D(m, n, z, filtrok, fx, fy, fz);\n"
/*401*/		"				le = KTensorMap(x * passox + m, y * passoy + n, z, entradatx, entradaty);\n"
/*402*/		"				f = filtro[lf];\n"
/*403*/		"				v = entrada[le];\n"
/*404*/		"				sum += f * v;\n"
/*405*/		"			}\n"
/*406*/		"		}\n"
/*407*/		"	}\n"
/*408*/		"	Z[k] = sum;\n"
/*409*/		"	saida[k] = func(fid, sum);\n"
/*410*/		"}\n"
/*411*/		"\n"
/*412*/		"kV convFCalcGradZ(Vector ds, Vector z, Vector dz, int fid, int k0) {\n"
/*413*/		"	int k = get_global_id(0) + k0;\n"
/*414*/		"	dz[k] = ds[k] * func(fid, z[k]);\n"
/*415*/		"}\n"
/*416*/		"\n"
/*417*/		"\n"
/*418*/		"\n"
/*419*/		"kV convFCalcGradIn(Vector filtro, Vector gradEntrada, Vector dz,\n"
/*420*/		"				   int fx, int fy, int fz,\n"
/*421*/		"				   int passox, int passoy,\n"
/*422*/		"				   int entradatx, int entradaty,\n"
/*423*/		"				   int saidatx, int saidaty, int saidatz,\n"
/*424*/		"				   int k0) {\n"
/*425*/		"	int k = get_global_id(0) + k0;\n"
/*426*/		"	int x, y, z;\n"
/*427*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*428*/		"\n"
/*429*/		"	Range range_filtro;\n"
/*430*/		"	range_filtro.min.x = 0;\n"
/*431*/		"	if (x + fx > entradatx) {\n"
/*432*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*433*/		"	}\n"
/*434*/		"	range_filtro.max.x = fx - 1;\n"
/*435*/		"	if (x - fx + 1 < 0) {\n"
/*436*/		"		range_filtro.max.x = x;\n"
/*437*/		"	}\n"
/*438*/		"	range_filtro.min.y = 0;\n"
/*439*/		"	if (y + fy > entradaty) {\n"
/*440*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*441*/		"	}\n"
/*442*/		"	range_filtro.max.y = fy - 1;\n"
/*443*/		"	if (y - fy + 1 < 0) {\n"
/*444*/		"		range_filtro.max.y = y;\n"
/*445*/		"	}\n"
/*446*/		"	REAL somaErro = 0, pesoAplicado = 0;\n"
/*447*/		"	int i, j;\n"
/*448*/		"	int lf, ls;\n"
/*449*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*450*/		"		i = (x - m) / passox;\n"
/*451*/		"		if (i * passox + m != x) continue;\n"
/*452*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*453*/		"			j = (y - n) / passoy;\n"
/*454*/		"			if (j * passoy + n != y) continue;\n"
/*455*/		"			for (int w = 0; w < saidatz; w++) {\n"
/*456*/		"				lf = KTensorMap4D(m, n, z, w, fx, fy, fz);\n"
/*457*/		"				ls = KTensorMap(i, j, w, saidatx, saidaty);\n"
/*458*/		"				pesoAplicado = filtro[lf];\n"
/*459*/		"				somaErro += pesoAplicado * dz[ls];\n"
/*460*/		"			}\n"
/*461*/		"		}\n"
/*462*/		"	}\n"
/*463*/		"	gradEntrada[k] = somaErro;\n"
/*464*/		"}\n"
/*465*/		"\n"
/*466*/		"kV convFCalcGradAndFixWeight(Vector filtros, Vector dz,\n"
/*467*/		"							 Vector entrada, Vector gradFiltro,\n"
/*468*/		"							 int fx, int fy, int fz,\n"
/*469*/		"							 int entrada_tx, int entrada_ty,\n"
/*470*/		"							 int saida_tx, int saida_ty,\n"
/*471*/		"							 int passox, int passoy,\n"
/*472*/		"							 REAL hitLearn, REAL momento, REAL weightDecay,\n"
/*473*/		"							 int k0) {\n"
/*474*/		"	int k = get_global_id(0) + k0;\n"
/*475*/		"	int m, n, z, l;\n"
/*476*/		"	KTensorRemap4D(k, m, n, z, l, fx, fy, fz)\n"
/*477*/		"	REAL soma = 0;\n"
/*478*/		"	int le, ls;\n"
/*479*/		"	for (int i = 0; i < saida_tx; ++i) {\n"
/*480*/		"		for (int j = 0; j < saida_ty; ++j) {\n"
/*481*/		"			le = KTensorMap(i * passox + m, j * passoy + n, z, entrada_tx, entrada_ty);\n"
/*482*/		"			ls = KTensorMap(i, j, l, saida_tx, saida_ty);\n"
/*483*/		"			soma += entrada[le]\n"
/*484*/		"					* dz[ls];\n"
/*485*/		"		}\n"
/*486*/		"	}\n"
/*487*/		"	REAL dw = soma + gradFiltro[k] * momento;\n"
/*488*/		"	REAL w = filtros[k];\n"
/*489*/		"	filtros[k] = w - hitLearn * (dw + w * weightDecay);\n"
/*490*/		"	gradFiltro[k] = dw;\n"
/*491*/		"}\n"
/*492*/		"//convNc.h\n"
/*493*/		"\n"
/*494*/		"kV convncSum(Vector W, Vector A, Vector Z, Vector S,\n"
/*495*/		"			 unsigned int fid,\n"
/*496*/		"			 unsigned int passox, int passoy,\n"
/*497*/		"			 unsigned int largx, unsigned int largy,\n"
/*498*/		"			 unsigned int entradatx, unsigned int entradaty,\n"
/*499*/		"			 unsigned int saidatx, unsigned int saidaty,\n"
/*500*/		"			 unsigned int fx, unsigned int fy, unsigned int fz,\n"
/*501*/		"			 int k0) {\n"
/*502*/		"	int k = get_global_id(0) + k0;\n"
/*503*/		"	int x, y, filtrok;\n"
/*504*/		"	KTensorRemap(k, x, y, filtrok, saidatx, saidaty)\n"
/*505*/		"	Ponto3d Kmapeado = {x * passox, y * passoy, 0};\n"
/*506*/		"	REAL sum = 0, f, v;\n"
/*507*/		"	for (int i = 0; i < fx; i++)\n"
/*508*/		"		for (int j = 0; j < fy; j++)\n"
/*509*/		"			for (int z = 0; z < fz; z++) {\n"
/*510*/		"				f = W[KTensorMap4D(i, j, z, filtrok, fx, fy, fz)];\n"
/*511*/		"				v = A[KTensorMap(Kmapeado.x + i * largx, Kmapeado.y + j * largy, z, entradatx, entradaty)];\n"
/*512*/		"\n"
/*513*/		"				sum += f * v;\n"
/*514*/		"			}\n"
/*515*/		"	Z[k] = sum;\n"
/*516*/		"	S[k] = func(fid, sum);\n"
/*517*/		"}\n"
/*518*/		"\n"
/*519*/		"kV convncCalcGradZ(Vector ds, Vector z, Vector dz, unsigned int fid, int k0) {\n"
/*520*/		"	int k = get_global_id(0) + k0;\n"
/*521*/		"	dz[k] = ds[k] * func(fid, z[k]);\n"
/*522*/		"}\n"
/*523*/		"\n"
/*524*/		"kV convncCalcGrads(Vector W,\n"
/*525*/		"				   Vector DA,\n"
/*526*/		"				   Vector dz,\n"
/*527*/		"				   unsigned int passox, unsigned int passoy,\n"
/*528*/		"				   unsigned int largx, unsigned int largy,\n"
/*529*/		"				   unsigned int entradatx, unsigned int entradaty,\n"
/*530*/		"				   unsigned int saidatx, unsigned int saidaty,\n"
/*531*/		"				   unsigned int fx, unsigned int fy, unsigned int fz,\n"
/*532*/		"				   int k0) {\n"
/*533*/		"	/**\n"
/*534*/		" * equacao a ser implementada \\n\n"
/*535*/		" * x = s*p + m*w \\n\n"
/*536*/		" * onde: \\n\n"
/*537*/		" * 	x é da entrada \\n\n"
/*538*/		" * 	s é da saida \\n\n"
/*539*/		" * 	m é do filtro\\n\n"
/*540*/		" * 	s = (x - m*w)/p \\n\n"
/*541*/		" */\n"
/*542*/		"	int k = get_global_id(0) + k0;\n"
/*543*/		"	int x, y, z;\n"
/*544*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*545*/		"	Range range_filtro;\n"
/*546*/		"	range_filtro.min.x = 0;\n"
/*547*/		"	if ((entradatx - x - (fx - 1) * largx) < 0) {\n"
/*548*/		"		range_filtro.min.x = -entradatx + x + fx;\n"
/*549*/		"	}\n"
/*550*/		"	range_filtro.max.x = fx - 1;\n"
/*551*/		"	if (x - (fx - 1) * largx < 0) {\n"
/*552*/		"		range_filtro.max.x = x / largx;\n"
/*553*/		"	}\n"
/*554*/		"	range_filtro.min.y = 0;\n"
/*555*/		"	if ((entradaty - y - (fy - 1) * largy) < 0) {\n"
/*556*/		"		range_filtro.min.y = -entradaty + y + fy;\n"
/*557*/		"	}\n"
/*558*/		"	range_filtro.max.y = fy - 1;\n"
/*559*/		"	if (y - (fy - 1) * largy < 0) {\n"
/*560*/		"		range_filtro.max.y = y / largy;\n"
/*561*/		"	}\n"
/*562*/		"	int sx, sy;\n"
/*563*/		"	REAL somaErro = 0, aux, pesoAplicado = 0;\n"
/*564*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*565*/		"		sx = (x - m * largx) / passox;\n"
/*566*/		"		if (sx * passox + m * largx != x)continue;\n"
/*567*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*568*/		"			sy = (y - n * largy) / passox;\n"
/*569*/		"			if (sy * passoy + n * largy != y)continue;\n"
/*570*/		"			for (int l = 0; l < fz; l++) {\n"
/*571*/		"				pesoAplicado = W[KTensorMap4D(m, n, z, l, fx, fy, fz)];\n"
/*572*/		"				aux = pesoAplicado * dz[KTensorMap(sx, sy, l, saidatx, saidaty)];\n"
/*573*/		"				somaErro += aux;\n"
/*574*/		"			}\n"
/*575*/		"		}\n"
/*576*/		"	}\n"
/*577*/		"	DA[k] = somaErro;\n"
/*578*/		"}\n"
/*579*/		"\n"
/*580*/		"kV convncCalcFiltro(Vector dz,\n"
/*581*/		"					Vector A,\n"
/*582*/		"					Vector W,\n"
/*583*/		"					Vector dW,\n"
/*584*/		"					unsigned int dw_x, unsigned int dw_y, unsigned int dw_z,\n"
/*585*/		"					unsigned int a_x, unsigned int a_y,\n"
/*586*/		"					unsigned int s_x, unsigned int s_y,\n"
/*587*/		"					unsigned int passox, unsigned int passoy,\n"
/*588*/		"					unsigned int largx, unsigned int largy,\n"
/*589*/		"					REAL hitlearn, REAL momento, REAL weightDecay,\n"
/*590*/		"					int k0) {\n"
/*591*/		"	int k = get_global_id(0) + k0;\n"
/*592*/		"	int m, n, z, l;\n"
/*593*/		"	KTensorRemap4D(k, m, n, z, l, dw_x, dw_y, dw_z)\n"
/*594*/		"	REAL soma = 0, aux;\n"
/*595*/		"	for (int i = 0; i < s_x; ++i) {\n"
/*596*/		"		for (int j = 0; j < s_y; ++j) {\n"
/*597*/		"			aux = A[KTensorMap(i * passox + m * largx, j * passoy + n * largy, z, a_x, a_y)]\n"
/*598*/		"				  * dz[KTensorMap(i, j, l, s_x, s_y)];\n"
/*599*/		"			soma += aux;\n"
/*600*/		"		}\n"
/*601*/		"	}\n"
/*602*/		"	dW[k] = soma + dW[k] * momento;\n"
/*603*/		"	W[k] = W[k] - hitlearn * (dW[k] + W[k] * weightDecay);\n"
/*604*/		"\n"
/*605*/		"}\n"
/*606*/		"\n"
/*607*/		"\n"
/*608*/		"\n"
/*609*/		"\n"
/*610*/		"//dropout.h\n"
/*611*/		"#define MAX_INT_DP  ((1UL << 31) - 1)\n"
/*612*/		"long randoml(unsigned long seed,unsigned long id) {\n"
/*613*/		"	seed += id;\n"
/*614*/		"	return (seed * 0x5deece66dL + 0xbL) & MAX_INT_DP;\n"
/*615*/		"}\n"
/*616*/		"\n"
/*617*/		"REAL randomD(unsigned long seed,unsigned long id) {\n"
/*618*/		"	return (REAL) randoml(seed, id) / (REAL) MAX_INT_DP;\n"
/*619*/		"}\n"
/*620*/		"\n"
/*621*/		"kV dropativa(Vector entrada, Vector saida, __global char *hitmap, long seed,\n"
/*622*/		"			 REAL pativa, int k0) {\n"
/*623*/		"	int i = get_global_id(0) + k0;\n"
/*624*/		"//	printf(\"kernel %lf %lf %g %g\\n\",randomD(seed, i),pativa,(REAL)(seed +i),(REAL)MAX_INT_DP);\n"
/*625*/		"	char teste = (char) (randomD(seed, i) <= pativa);\n"
/*626*/		"	hitmap[i] = teste;\n"
/*627*/		"	saida[i] = teste * entrada[i];\n"
/*628*/		"}\n"
/*629*/		"\n"
/*630*/		"\n"
/*631*/		"kV dropcalcgrad(Vector gradentrada, __global char *hitmap, Vector gradnext, int k0) {\n"
/*632*/		"	int i = get_global_id(0) + k0;\n"
/*633*/		"	gradentrada[i] = hitmap[i] * gradnext[i];\n"
/*634*/		"}\n"
/*635*/		"\n"
/*636*/		"//fullconnect.h\n"
/*637*/		"\n"
/*638*/		"/**\n"
/*639*/		" *\n"
/*640*/		" * @param entrada (N,1,1)\n"
/*641*/		" * @param pesos (M,N,1)\n"
/*642*/		" * @param b (N,1,1)\n"
/*643*/		" * @param z (N,1,1)\n"
/*644*/		" * @param saida (N,1,1)\n"
/*645*/		" * @param funcaoativacao\n"
/*646*/		" * @param pesosx M\n"
/*647*/		" * @param pesosy N\n"
/*648*/		" * @param k0\n"
/*649*/		" */\n"
/*650*/		"kV fullfeed(Vector entrada, Vector pesos, Vector b, Vector z, Vector saida,\n"
/*651*/		"			int funcaoativacao, int pesosx, int pesosy, int k0) {\n"
/*652*/		"	int m = get_global_id(0) + k0;\n"
/*653*/		"	REAL valorEntrada = 0;\n"
/*654*/		"	int n;\n"
/*655*/		"	for (n = 0; n < pesosy; n++) {\n"
/*656*/		"		valorEntrada += entrada[n] * pesos[KTensorMap(m, n, 0, pesosx, pesosy)];\n"
/*657*/		"	}\n"
/*658*/		"	z[m] = valorEntrada + b[m];\n"
/*659*/		"	saida[m] = func(funcaoativacao, z[m]);\n"
/*660*/		"}\n"
/*661*/		"\n"
/*662*/		"kV fullCalcDWandFix(Vector a,\n"
/*663*/		"					Vector w,\n"
/*664*/		"					Vector dw,\n"
/*665*/		"					Vector dz,\n"
/*666*/		"					REAL hitlearn,\n"
/*667*/		"					REAL momento,\n"
/*668*/		"					REAL decaimentoDePeso,\n"
/*669*/		"					int pesosy,\n"
/*670*/		"					int k0) {\n"
/*671*/		"	int k = get_global_id(0) + k0;\n"
/*672*/		"	int m, n;\n"
/*673*/		"	m = k / pesosy;\n"
/*674*/		"	n = k % pesosy;\n"
/*675*/		"	dw[k] = dz[m] * a[n] + dw[k] * momento;\n"
/*676*/		"	w[k] = w[k] - hitlearn * (dw[k] + w[k] * decaimentoDePeso);\n"
/*677*/		"}\n"
/*678*/		"\n"
/*679*/		"kV fullCalcDz(Vector dz, Vector ds, Vector z, Vector b, Vector db,\n"
/*680*/		"			  int dfa, REAL hitlearn,\n"
/*681*/		"			  REAL momento, REAL decaimentoDePeso,\n"
/*682*/		"			  int k0) {\n"
/*683*/		"	int m = get_global_id(0) + k0;\n"
/*684*/		"	dz[m] = ds[m] * func(dfa, z[m]);\n"
/*685*/		"}\n"
/*686*/		"\n"
/*687*/		"kV fullCalcDzAndFixB(Vector dz, Vector ds, Vector z, Vector b,\n"
/*688*/		"					 Vector db, int dfa, REAL hitlearn,\n"
/*689*/		"					 REAL momento, REAL decaimentoDePeso,\n"
/*690*/		"					 int k0) {\n"
/*691*/		"	int m = get_global_id(0) + k0;\n"
/*692*/		"	dz[m] = ds[m] * func(dfa, z[m]);\n"
/*693*/		"	db[m] = dz[m] + db[m] * momento;\n"
/*694*/		"	b[m] = b[m] - hitlearn * (db[m] + b[m] * decaimentoDePeso);\n"
/*695*/		"}\n"
/*696*/		"\n"
/*697*/		"kV fullcalcin(Vector dz, Vector da, Vector w, int pesosx, int pesosy,\n"
/*698*/		"			  int k0) {\n"
/*699*/		"	int m = get_global_id(0) + k0;\n"
/*700*/		"	REAL soma = 0;\n"
/*701*/		"	for (int n = 0; n < pesosx; ++n) {\n"
/*702*/		"		soma += dz[n] * w[KTensorMap(n, m, 0, pesosx, pesosy)];\n"
/*703*/		"	}\n"
/*704*/		"	da[m] = soma;\n"
/*705*/		"}\n"
/*706*/		"\n"
/*707*/		"//padding.h\n"
/*708*/		"\n"
/*709*/		"kV paddingfeed(Vector in,Vector out,\n"
/*710*/		"			   unsigned int txi,unsigned int tyi,\n"
/*711*/		"			   unsigned int txo,unsigned int tyo,\n"
/*712*/		"			   unsigned int t, unsigned int l ,\n"
/*713*/		"			   int k0){\n"
/*714*/		"	int k = get_global_id(0) + k0;\n"
/*715*/		"	int x, y, z;\n"
/*716*/		"	KTensorRemap(k, x, y, z, txi, tyi)\n"
/*717*/		"	int s = KTensorMap(x+t,y+l,z,txo,tyo);\n"
/*718*/		"	out[s] = in[k];\n"
/*719*/		"}\n"
/*720*/		"kV paddingBack(Vector gradNext,Vector gradin,\n"
/*721*/		"			   unsigned int txi, unsigned int tyi,\n"
/*722*/		"			   unsigned int txo,unsigned int tyo,\n"
/*723*/		"			   unsigned int t, unsigned int l , int k0){\n"
/*724*/		"	int k = get_global_id(0) + k0;\n"
/*725*/		"	int x, y, z;\n"
/*726*/		"	KTensorRemap(k, x, y, z, txi, tyi)\n"
/*727*/		"	int s = KTensorMap(x+t,y+l,z,txo,tyo);\n"
/*728*/		"	gradin[k] = gradNext[s];\n"
/*729*/		"}\n"
/*730*/		"//poolav.h\n"
/*731*/		"kV poolAVativa(Vector entrada, Vector saida,\n"
/*732*/		"			   int passox, int passoy,\n"
/*733*/		"			   int fx, int fy,\n"
/*734*/		"			   int saidatx, int saidaty, int entradatx, int entradaty, int k0) {\n"
/*735*/		"	int k = get_global_id(0) + k0;\n"
/*736*/		"	int x, y, z;\n"
/*737*/		"	KTensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*738*/		"\n"
/*739*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*740*/		"	REAL soma = 0;\n"
/*741*/		"\n"
/*742*/		"	for (int i = 0; i < fx; ++i) {\n"
/*743*/		"		for (int j = 0; j < fy; ++j) {\n"
/*744*/		"			soma += entrada[KTensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*745*/		"		}\n"
/*746*/		"	}\n"
/*747*/		"	saida[k] = soma / (fx * fy);\n"
/*748*/		"}\n"
/*749*/		"\n"
/*750*/		"\n"
/*751*/		"kV poolAvCalcGrads(Vector entrada, Vector gradEntrada, Vector gradNext, Vector saida,\n"
/*752*/		"				   int fx, int fy, int px, int py,\n"
/*753*/		"				   int entradatx, int entradaty,\n"
/*754*/		"				   int saidatx, int saidaty,\n"
/*755*/		"				   int k0) {\n"
/*756*/		"	int k = get_global_id(0) + k0;\n"
/*757*/		"	int x, y, z;\n"
/*758*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*759*/		"	Range range_filtro;\n"
/*760*/		"	range_filtro.min.x = 0;\n"
/*761*/		"	if (x + fx > entradatx) {\n"
/*762*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*763*/		"	}\n"
/*764*/		"	range_filtro.max.x = fx - 1;\n"
/*765*/		"	if (x - fx + 1 < 0) {\n"
/*766*/		"		range_filtro.max.x = x;\n"
/*767*/		"	}\n"
/*768*/		"	range_filtro.min.y = 0;\n"
/*769*/		"	if (y + fy > entradaty) {\n"
/*770*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*771*/		"	}\n"
/*772*/		"	range_filtro.max.y = fy - 1;\n"
/*773*/		"	if (y - fy + 1 < 0) {\n"
/*774*/		"		range_filtro.max.y = y;\n"
/*775*/		"	}\n"
/*776*/		"	int i, j;//saida\n"
/*777*/		"	REAL soma = 0;\n"
/*778*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*779*/		"		i = (x - m) / px;\n"
/*780*/		"		if (i * px + m != x)continue;\n"
/*781*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*782*/		"			j = (y - n) / py;\n"
/*783*/		"			if (j * py + n != y)continue;\n"
/*784*/		"			soma += gradNext[KTensorMap(i, j, z, saidatx, saidaty)];\n"
/*785*/		"		}\n"
/*786*/		"	}\n"
/*787*/		"	gradEntrada[KTensorMap(x, y, z, entradatx, entradaty)] = soma / (fx * fy);\n"
/*788*/		"\n"
/*789*/		"}\n"
/*790*/		"\n"
/*791*/		"\n"
/*792*/		"//poolMax.h\n"
/*793*/		"kV poolativa(Vector entrada, Vector saida,\n"
/*794*/		"			 int passox, int passoy,\n"
/*795*/		"			 int filtrox, int filtroy,\n"
/*796*/		"			 int saidatx, int saidaty,\n"
/*797*/		"			 int entradatx, int entradaty, int k0) {\n"
/*798*/		"	int k = get_global_id(0) + k0;\n"
/*799*/		"	int x, y, z;\n"
/*800*/		"	KTensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*801*/		"\n"
/*802*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*803*/		"	REAL mval, v;\n"
/*804*/		"	mval = -DBL_MAX;\n"
/*805*/		"	for (int i = 0; i < filtrox; ++i) {\n"
/*806*/		"		for (int j = 0; j < filtroy; ++j) {\n"
/*807*/		"			v = entrada[KTensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*808*/		"			if (v > mval)\n"
/*809*/		"				mval = v;\n"
/*810*/		"		}\n"
/*811*/		"	}\n"
/*812*/		"	saida[k] = mval;\n"
/*813*/		"}\n"
/*814*/		"\n"
/*815*/		"\n"
/*816*/		"kV poolCalcGrads(Vector entrada, Vector gradEntrada,\n"
/*817*/		"				 Vector gradNext, Vector saida,\n"
/*818*/		"				 int fx, int fy, int px, int py,\n"
/*819*/		"				 int entradatx, int entradaty,\n"
/*820*/		"				 int saidatx, int saidaty,\n"
/*821*/		"				 int k0) {\n"
/*822*/		"	int k = get_global_id(0) + k0;\n"
/*823*/		"	int x, y, z;\n"
/*824*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*825*/		"	Range range_filtro;\n"
/*826*/		"	if (x + fx > entradatx) {\n"
/*827*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*828*/		"	}\n"
/*829*/		"	range_filtro.max.x = fx - 1;\n"
/*830*/		"	if (x - fx + 1 < 0) {\n"
/*831*/		"		range_filtro.max.x = x;\n"
/*832*/		"	}\n"
/*833*/		"	range_filtro.min.y = 0;\n"
/*834*/		"	if (y + fy > entradaty) {\n"
/*835*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*836*/		"	}\n"
/*837*/		"	range_filtro.max.y = fy - 1;\n"
/*838*/		"	if (y - fy + 1 < 0) {\n"
/*839*/		"		range_filtro.max.y = y;\n"
/*840*/		"	}\n"
/*841*/		"	int i, j;//saida\n"
/*842*/		"	gradEntrada[KTensorMap(x, y, z, entradatx, entradaty)] = 0;\n"
/*843*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*844*/		"		i = (x - m) / px;\n"
/*845*/		"		if (i * px + m != x)continue;\n"
/*846*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*847*/		"			j = (y - n) / py;\n"
/*848*/		"			if (j * py + n != y)continue;\n"
/*849*/		"			if (entrada[k] == saida[KTensorMap(i, j, z, saidatx, saidaty)]) {\n"
/*850*/		"				gradEntrada[k] = gradNext[KTensorMap(i, j, z, saidatx, saidaty)];\n"
/*851*/		"				return;\n"
/*852*/		"			}\n"
/*853*/		"		}\n"
/*854*/		"	}\n"
/*855*/		"\n"
/*856*/		"}\n"
/*857*/		"\n"
/*858*/		"\n"
/*859*/		"//poolMin.h\n"
/*860*/		"kV poolativaMin(Vector entrada, Vector saida,\n"
/*861*/		"				int passox, int passoy,\n"
/*862*/		"				int filtrox, int filtroy,\n"
/*863*/		"				int saidatx, int saidaty,\n"
/*864*/		"				int entradatx, int entradaty, int k0) {\n"
/*865*/		"	int k = get_global_id(0) + k0;\n"
/*866*/		"	int x, y, z;\n"
/*867*/		"	KTensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*868*/		"\n"
/*869*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*870*/		"	REAL mval, v;\n"
/*871*/		"	mval = DBL_MAX;\n"
/*872*/		"	for (int i = 0; i < filtrox; ++i) {\n"
/*873*/		"		for (int j = 0; j < filtroy; ++j) {\n"
/*874*/		"			v = entrada[KTensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*875*/		"			if (v < mval)\n"
/*876*/		"				mval = v;\n"
/*877*/		"		}\n"
/*878*/		"	}\n"
/*879*/		"	saida[k] = mval;\n"
/*880*/		"}\n"
/*881*/		"\n"
/*882*/		"\n"
/*883*/		"//prelu.h\n"
/*884*/		"kV preluativa(Vector entrada, Vector saida, Vector A, int k0) {\n"
/*885*/		"	int k = get_global_id(0) + k0;\n"
/*886*/		"	REAL v = entrada[k];\n"
/*887*/		"	if (v < 0)\n"
/*888*/		"		v = v * A[k];\n"
/*889*/		"	saida[k] = v;\n"
/*890*/		"}\n"
/*891*/		"\n"
/*892*/		"kV prelucalcgrad(Vector gradentrada, Vector entrada, Vector gradnext, Vector A, Vector dA,\n"
/*893*/		"				 int learn, REAL hitlearn, REAL momento,\n"
/*894*/		"				 REAL decaimento,\n"
/*895*/		"				 int k0) {\n"
/*896*/		"	int k = get_global_id(0) + k0;\n"
/*897*/		"	REAL v = entrada[k];\n"
/*898*/		"	if (v < 0) {\n"
/*899*/		"		gradentrada[k] = gradnext[k] * A[k];\n"
/*900*/		"		dA[k] = gradnext[k] + momento * dA[k];\n"
/*901*/		"	} else {\n"
/*902*/		"		gradentrada[k] = gradnext[k];\n"
/*903*/		"		dA[k] = momento * dA[k];\n"
/*904*/		"	}\n"
/*905*/		"	if (learn)\n"
/*906*/		"		A[k] = A[k] - hitlearn * (dA[k] + A[k] * decaimento);\n"
/*907*/		"}\n"
/*908*/		"\n"
/*909*/		"kV preluonlyfix(Vector entrada, Vector gradnext, Vector A, Vector dA,\n"
/*910*/		"				REAL hitlearn, REAL momento,\n"
/*911*/		"				REAL decaimento,\n"
/*912*/		"				int k0) {\n"
/*913*/		"	int k = get_global_id(0) + k0;\n"
/*914*/		"	REAL v = entrada[k];\n"
/*915*/		"	if (v < 0) {\n"
/*916*/		"		dA[k] = gradnext[k] + momento * dA[k];\n"
/*917*/		"	} else {\n"
/*918*/		"		dA[k] = momento * dA[k];\n"
/*919*/		"	}\n"
/*920*/		"	A[k] = A[k] - hitlearn * (dA[k] + A[k] * decaimento);\n"
/*921*/		"}\n"
/*922*/		"\n"
/*923*/		"//relu.h\n"
/*924*/		"\n"
/*925*/		"kV reluativa(Vector entrada, Vector saida, REAL menor, REAL maior, int k0) {\n"
/*926*/		"	int k = get_global_id(0) + k0;\n"
/*927*/		"	saida[k] = entrada[k] < 0.0 ? (entrada[k] * menor) : (entrada[k] * maior);\n"
/*928*/		"}\n"
/*929*/		"\n"
/*930*/		"\n"
/*931*/		"kV relucalcgrad(Vector gradentrada, Vector entrada, Vector gradnext, REAL menor, REAL maior, int k0) {\n"
/*932*/		"	int k = get_global_id(0) + k0;\n"
/*933*/		"	gradentrada[k] = entrada[k] < 0.0 ? (menor * gradnext[k]) : (maior * gradnext[k]);\n"
/*934*/		"}\n"
/*935*/		"\n"
/*936*/		"//softmax.h\n"
/*937*/		"/**\n"
/*938*/		" * @goal calcular e^a(x,y,z)\n"
/*939*/		" * @iteration dimensão de a (x,y,z)\n"
/*940*/		" * @param entrada Tensor de entrada (leitura)\n"
/*941*/		" * @param exponent Tensor e^entrada (escrita)\n"
/*942*/		" * @param k0 usado internamente no kernel\n"
/*943*/		" */\n"
/*944*/		"kV softmaxExp(Vector entrada, Vector exponent, int k0) {\n"
/*945*/		"	int k = get_global_id(0) + k0;\n"
/*946*/		"	exponent[k] = EXP(entrada[k]);\n"
/*947*/		"}\n"
/*948*/		"\n"
/*949*/		"/***\n"
/*950*/		" * @goal encontrar a soma de cada dimensão z\n"
/*951*/		" * @iteration dimensão z da entrada a(:,:,z)\n"
/*952*/		" * @param eps Tensor exponencial da entrada (leitura)\n"
/*953*/		" * @param soma Tensor da soma das exponenciais (escrita)\n"
/*954*/		" * @param saidatx dimensão x da saída\n"
/*955*/		" * @param saidaty dimensão x da saída\n"
/*956*/		" * @param k0 usado internamente no kernel\n"
/*957*/		" */\n"
/*958*/		"kV softmaxSomaExp(Vector eps, Vector soma, int saidatx, int saidaty, int k0) {\n"
/*959*/		"	int z = get_global_id(0) + k0;\n"
/*960*/		"	int x, y;\n"
/*961*/		"	REAL sum = 0;\n"
/*962*/		"	for (x = 0; x < saidatx; x++) {\n"
/*963*/		"		for (y = 0; y < saidaty; y++) {\n"
/*964*/		"			sum += eps[KTensorMap(x, y, z, saidatx, saidaty)];\n"
/*965*/		"		}\n"
/*966*/		"	}\n"
/*967*/		"	soma[z] = sum;\n"
/*968*/		"}\n"
/*969*/		"/***\n"
/*970*/		" * @goal Normalizar a exponencial pela soma\n"
/*971*/		" *  * @iteration dimensão da saída  s(x,y,z)\n"
/*972*/		" * @param exponet Tensor exponencial da entrada (leitura)\n"
/*973*/		" * @param soma Tensor da soma das exponenciais (leitura)\n"
/*974*/		" * @param saida Tensor de saída (escrita)\n"
/*975*/		" * @param saidatx dimensão x da saída\n"
/*976*/		" * @param saidaty dimensão x da saída\n"
/*977*/		" * @param k0 usado internamente no kernel\n"
/*978*/		" */\n"
/*979*/		"kV softmaxNormaliza(Vector exponet, Vector soma, Vector saida, int saidatx, int saidaty, int k0) {\n"
/*980*/		"	int k = get_global_id(0) + k0;\n"
/*981*/		"	int x, y, z;\n"
/*982*/		"	KTensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*983*/		"	saida[k] = exponet[k] / soma[z];\n"
/*984*/		"}\n"
/*985*/		"/**\n"
/*986*/		" * @goal Calcular os gradientes de entrada\n"
/*987*/		" * @iteration dimensão da entrada a(x,y,z)\n"
/*988*/		" * @param da Tensor de gradientes de entrada (escrita)\n"
/*989*/		" * @param s Tensor de saida (leitura)\n"
/*990*/		" * @param ds Tensor gradiente da saída (leitura)\n"
/*991*/		" * @param sx dimensão x da saída\n"
/*992*/		" * @param sy dimensão y da saída\n"
/*993*/		" * @param k0 usado internamente no kernel\n"
/*994*/		" */\n"
/*995*/		"kV softMaxcalcgrad(Vector da, Vector s, Vector ds, int sx, int sy, int k0) {\n"
/*996*/		"	int k = get_global_id(0) + k0;\n"
/*997*/		"	int i, z, j;\n"
/*998*/		"	int sxy = sx * sy;\n"
/*999*/		"	KTensorRemap2D(k, z, i, sxy);\n"
/*1000*/		"	REAL yi = s[k];\n"
/*1001*/		"	REAL soma = 0.0;\n"
/*1002*/		"	for (j = 0; j < sxy; ++j) {\n"
/*1003*/		"		if (j == i) {\n"
/*1004*/		"			soma += yi * (1 - yi) * ds[j + z * sxy];\n"
/*1005*/		"//			printf(\"v(%d,%d,%d) =  %f, %f %f;\\n\", i+1, j+1, z+1, yi * (1 - yi),s[j + z * sxy],yi);\n"
/*1006*/		"		} else {\n"
/*1007*/		"			soma += -yi * s[j + z * sxy] * ds[j + z * sxy];\n"
/*1008*/		"//			printf(\"v(%d,%d,%d) =  %f, %f %f;\\n\", i+1, j+1, z+1, yi * -s[j + z * sxy],s[j + z * sxy],yi);\n"
/*1009*/		"		}\n"
/*1010*/		"	}\n"
/*1011*/		"	da[k] = soma;\n"
/*1012*/		"}\n"
/*1013*/		"\n"
/*1014*/		"/**\n"
/*1015*/		" * @goal Encontrar o maximo e o indice de cada dimensão z\n"
/*1016*/		" * @iteration dimensão z da entrada a(:,:,z)\n"
/*1017*/		" * @param a entrada\n"
/*1018*/		" * @param mx tensor maximos\n"
/*1019*/		" * @param i_max tensor indice de maximos\n"
/*1020*/		" * @param ax entrada x\n"
/*1021*/		" * @param ay entrada y\n"
/*1022*/		" * @param k0 uso interno no kernel\n"
/*1023*/		" */\n"
/*1024*/		"kV softmaxFindMax(Vector a, Vector mx, __global int *i_max, int ax, int ay, int k0) {\n"
/*1025*/		"	int z = get_global_id(0) + k0;\n"
/*1026*/		"	int x, y;\n"
/*1027*/		"	REAL maximo = a[KTensorMap(0, 0, z, ax, ay)];\n"
/*1028*/		"	REAL adata;\n"
/*1029*/		"	int imax = 0;\n"
/*1030*/		"	for (x = 0; x < ax; x++) {\n"
/*1031*/		"		for (y = 0; y < ay; y++) {\n"
/*1032*/		"			adata = a[KTensorMap(x, y, z, ax, ay)];\n"
/*1033*/		"			if (maximo < adata) {\n"
/*1034*/		"				maximo = adata;\n"
/*1035*/		"				imax = x * ay + y;\n"
/*1036*/		"			}\n"
/*1037*/		"		}\n"
/*1038*/		"	}\n"
/*1039*/		"	i_max[z] = imax;\n"
/*1040*/		"	mx[z] = maximo;\n"
/*1041*/		"}\n"
/*1042*/		"\n"
/*1043*/		"/**\n"
/*1044*/		" * @goal calcular e^(a(x,y,z) - max(a))\n"
/*1045*/		" * @iteration dimensão de a (x,y,z)\n"
/*1046*/		" * @param entrada Tensor de entrada (leitura)\n"
/*1047*/		" * @param exponent Tensor e^entrada (escrita)\n"
/*1048*/		" * @param mx tensor maximos\n"
/*1049*/		" * @param ax entrada x\n"
/*1050*/		" * @param ay entrada y\n"
/*1051*/		" * @param k0 usado internamente no kernel\n"
/*1052*/		" */\n"
/*1053*/		"kV softmaxExpNorm(Vector entrada, Vector exponent, Vector mx, int ax, int ay, int k0) {\n"
/*1054*/		"	int k = get_global_id(0) + k0;\n"
/*1055*/		"	int x, y, z;\n"
/*1056*/		"	KTensorRemap(k, x, y, z, ax, ay);\n"
/*1057*/		"	exponent[k] = EXP(entrada[k] - mx[z]);\n"
/*1058*/		"}\n"
/*1059*/		"\n"
/*1060*/		"#endif //GAB_KERNELS_OPENCL_H\n"
;
const char *getInternalDefaultKernel() {
	return __default_kernel__;
}