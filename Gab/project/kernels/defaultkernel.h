//
// Created by Henrique on 14/08/2021.
//
const char __default_kernel__[] = 
/*1*/		"#ifndef GAB_KERNELS_OPENCL_H\n"
/*2*/		"#define GAB_KERNELS_OPENCL_H\n"
/*3*/		"//utils.h\n"
/*4*/		"// Created by Xx220xX on 10/05/2020.\n"
/*5*/		"#ifndef ATIVATIONSFUNCTIONS_H\n"
/*6*/		"#define ATIVATIONSFUNCTIONS_H\n"
/*7*/		"#define USEFLOAT 1\n"
/*8*/		"\n"
/*9*/		"#if (USEFLOAT == 1)\n"
/*10*/		"#define    REAL float\n"
/*11*/		"#define    TANH tanh\n"
/*12*/		"#define    EXP exp\n"
/*13*/		"#define    SQRT sqrt\n"
/*14*/		"#define    REALMAX FLT_MAX\n"
/*15*/		"#define    REALMIN FLT_MIN\n"
/*16*/		"#else\n"
/*17*/		"#define	REALMAX DBL_MAX\n"
/*18*/		"#define	REALMIN DBL_MIN\n"
/*19*/		"#define	REAL double\n"
/*20*/		"#define	TANH tanh\n"
/*21*/		"#define	EXP exp\n"
/*22*/		"#define	SQRT sqrt\n"
/*23*/		"#endif\n"
/*24*/		"#define Vector __global REAL *\n"
/*25*/		"\n"
/*26*/		"#define kV __kernel void\n"
/*27*/		"\n"
/*28*/		"#define KTensorMap(x, y, z, tx, ty)((z)*(ty*tx)+(x)*ty+(y))\n"
/*29*/		"\n"
/*30*/		"#define KTensorMap4D(x, y, z, l, tx, ty, tz)((l)*(ty)*(tx)*(tz)+(z)*(ty*tx)+(x)*ty+(y))\n"
/*31*/		"\n"
/*32*/		"#define KTensorRemap4D(total, _x_, _y_, _z_, _l_, tx, ty, tz)\\\n"
/*33*/		"_y_ = total%ty      ;                                        \\\n"
/*34*/		"_x_ = (total - _y_)%(ty*tx)/ty ;                             \\\n"
/*35*/		"_z_ = (total- _x_*ty - _y_)%(tx*ty*tz)/(ty*tx)  ;            \\\n"
/*36*/		"_l_ = (total -_z_*tx*ty -_x_*ty - _y_)/(tx*ty*tz);\n"
/*37*/		"\n"
/*38*/		"\n"
/*39*/		"#define KTensorRemap(total, _x_, _y_, _z_, tx, ty)\\\n"
/*40*/		"_y_ = total % ty;\\\n"
/*41*/		"_x_ = ((total - _y_) % (ty * tx)) / ty;\\\n"
/*42*/		"_z_ = (k - _x_ * ty - _y_) / (tx * ty);\n"
/*43*/		"\n"
/*44*/		"#define KTensorRemap2D(total, x, y, ty)\\\n"
/*45*/		"y = total % ty;\\\n"
/*46*/		"x = total/ ty;\n"
/*47*/		"\n"
/*48*/		"typedef struct {\n"
/*49*/		"	int x, y, z;\n"
/*50*/		"} Ponto3d;\n"
/*51*/		"\n"
/*52*/		"typedef struct {\n"
/*53*/		"	Ponto3d min, max;\n"
/*54*/		"} Range;\n"
/*55*/		"\n"
/*56*/		"\n"
/*57*/		"REAL sigmoid(REAL x) {\n"
/*58*/		"	return 1.0 / (1.0 + EXP(-x));\n"
/*59*/		"}\n"
/*60*/		"\n"
/*61*/		"REAL difsigmoid(REAL x) {\n"
/*62*/		"	REAL tmp = sigmoid(x);\n"
/*63*/		"	return tmp * (1.0 - tmp);\n"
/*64*/		"}\n"
/*65*/		"\n"
/*66*/		"REAL tanghG(REAL x) {\n"
/*67*/		"	return TANH(x);\n"
/*68*/		"}\n"
/*69*/		"\n"
/*70*/		"REAL diftanhG(REAL x) {\n"
/*71*/		"	REAL tmp = TANH(x);\n"
/*72*/		"	return (1.0 - tmp * tmp);\n"
/*73*/		"}\n"
/*74*/		"\n"
/*75*/		"REAL relu(REAL x) {\n"
/*76*/		"	return x > 0 ? x : 0.0;\n"
/*77*/		"}\n"
/*78*/		"\n"
/*79*/		"REAL difrelu(REAL x) {\n"
/*80*/		"	return x > 0 ? 1.0 : 0.0;\n"
/*81*/		"}\n"
/*82*/		"\n"
/*83*/		"REAL alan(REAL x) {\n"
/*84*/		"	if (x > 1) {\n"
/*85*/		"		return log10(x) + 0.7615941559557649;\n"
/*86*/		"	} else if (x < -1) {\n"
/*87*/		"		return -log10(-x) - 0.7615941559557649;\n"
/*88*/		"	}\n"
/*89*/		"	return tanghG(x);\n"
/*90*/		"}\n"
/*91*/		"\n"
/*92*/		"REAL difalan(REAL x) {\n"
/*93*/		"	if (x > 1) {\n"
/*94*/		"		return 0.419978 / x;\n"
/*95*/		"	} else if (x < 1) {\n"
/*96*/		"		return -0.419978 / x;\n"
/*97*/		"	}\n"
/*98*/		"	return diftanhG(x);\n"
/*99*/		"}\n"
/*100*/		"\n"
/*101*/		"REAL func(unsigned int id, REAL x) {\n"
/*102*/		"	switch (id) {\n"
/*103*/		"		case 0:\n"
/*104*/		"			return sigmoid(x);\n"
/*105*/		"		case 1:\n"
/*106*/		"			return difsigmoid(x);\n"
/*107*/		"		case 2:\n"
/*108*/		"			return tanghG(x);\n"
/*109*/		"		case 3:\n"
/*110*/		"			return diftanhG(x);\n"
/*111*/		"		case 4:\n"
/*112*/		"			return relu(x);\n"
/*113*/		"		case 5:\n"
/*114*/		"			return difrelu(x);\n"
/*115*/		"		case 6:\n"
/*116*/		"			return x;\n"
/*117*/		"		case 7:\n"
/*118*/		"			return 1;\n"
/*119*/		"		case 8:\n"
/*120*/		"			return alan(x);\n"
/*121*/		"		case 9:\n"
/*122*/		"			return difalan(x);\n"
/*123*/		"		default:\n"
/*124*/		"			return 0;\n"
/*125*/		"	}\n"
/*126*/		"}\n"
/*127*/		"\n"
/*128*/		"#endif\n"
/*129*/		"//bathnorm.h\n"
/*130*/		"/// achar a media\n"
/*131*/		"/// ativa 1\n"
/*132*/		"kV BatchNormMedia(Vector entrada, Vector media, int entradatx, int entradaty, int k0) {\n"
/*133*/		"	int z = get_global_id(0) + k0;\n"
/*134*/		"	int x, y;\n"
/*135*/		"	REAL m = 0;\n"
/*136*/		"	for (x = 0; x < entradatx; x++) {\n"
/*137*/		"		for (y = 0; y < entradaty; y++) {\n"
/*138*/		"			m += entrada[KTensorMap(x, y, z, entradatx, entradaty)];\n"
/*139*/		"		}\n"
/*140*/		"	}\n"
/*141*/		"	media[z] = m / (REAL) (entradatx * entradaty);\n"
/*142*/		"}\n"
/*143*/		"\n"
/*144*/		"kV BatchNormInvDesv(Vector a, Vector media, Vector inv_desv, REAL episolon, int ax, int ay, int k0) {\n"
/*145*/		"	int z = get_global_id(0) + k0;\n"
/*146*/		"	REAL sum = 0;\n"
/*147*/		"	REAL tmp;\n"
/*148*/		"	for (int x = 0; x < ax; x++) {\n"
/*149*/		"		for (int y = 0; y < ay; y++) {\n"
/*150*/		"			tmp = (a[KTensorMap(x, y, z, ax, ay)] - media[z]);\n"
/*151*/		"			sum += tmp * tmp;\n"
/*152*/		"		}\n"
/*153*/		"	}\n"
/*154*/		"	sum = sum / (ax * ay);\n"
/*155*/		"	inv_desv[z] = 1.0 / sqrt(sum + episolon);\n"
/*156*/		"}\n"
/*157*/		"\n"
/*158*/		"kV BatchNormNormaliza(Vector saida, Vector norma, Vector a, Vector media, Vector inv_std, Vector Y, Vector B, int ax, int ay, int k0) {\n"
/*159*/		"	int x, y, z;\n"
/*160*/		"	int k = get_global_id(0) + k0;\n"
/*161*/		"	KTensorRemap(k, x, y, z, ax, ay)\n"
/*162*/		"	norma[k] = (a[k] - media[z]) * inv_std[z];\n"
/*163*/		"	saida[k] = norma[k] * Y[z] + B[z];\n"
/*164*/		"}\n"
/*165*/		"\n"
/*166*/		"kV BatchNormaCalcDnorm(Vector dnorm, Vector ds, Vector Y, int ax, int ay, int k0) {\n"
/*167*/		"	int x, y, z;\n"
/*168*/		"	int k = get_global_id(0) + k0;\n"
/*169*/		"	KTensorRemap(k, x, y, z, ax, ay)\n"
/*170*/		"	dnorm[k] = ds[k] * Y[z];\n"
/*171*/		"}\n"
/*172*/		"\n"
/*173*/		"kV BatchNormMediadnorm_norma(Vector norm, Vector dnorm, Vector mdnorm, Vector mdnormnorm, int ax, int ay, int k0) {\n"
/*174*/		"	int z = get_global_id(0) + k0;\n"
/*175*/		"	int x, y;\n"
/*176*/		"	REAL md = 0;\n"
/*177*/		"	REAL m = 0;\n"
/*178*/		"	REAL tmp;\n"
/*179*/		"	for (x = 0; x < ax; x++) {\n"
/*180*/		"		for (y = 0; y < ay; y++) {\n"
/*181*/		"			m += dnorm[KTensorMap(x, y, z, ax, ay)];\n"
/*182*/		"			md += (dnorm[KTensorMap(x, y, z, ax, ay)] * norm[KTensorMap(x, y, z, ax, ay)]);\n"
/*183*/		"		}\n"
/*184*/		"	}\n"
/*185*/		"	mdnorm[z] = m / (REAL) (ax * ay);\n"
/*186*/		"	mdnormnorm[z] = md / (REAL) (ax * ay);\n"
/*187*/		"}\n"
/*188*/		"\n"
/*189*/		"kV BatchNormaCalcDa(Vector da, Vector norm, Vector dnorm, Vector mdnorm, Vector mdnormnorm, Vector inv_std, int ax, int ay, int k0) {\n"
/*190*/		"	int x, y, z;\n"
/*191*/		"	int k = get_global_id(0) + k0;\n"
/*192*/		"	KTensorRemap(k, x, y, z, ax, ay)\n"
/*193*/		"	da[k] = inv_std[z] * (dnorm[k] - mdnorm[z] - norm[k] * mdnormnorm[z]);\n"
/*194*/		"}\n"
/*195*/		"\n"
/*196*/		"\n"
/*197*/		"kV BatchNormaCalcdYdB(Vector ds, Vector norma, Vector gradY, Vector gradB, long batchSize, int ax, int ay, int k0) {\n"
/*198*/		"	int z = get_global_id(0) + k0;\n"
/*199*/		"	REAL sumY = 0;\n"
/*200*/		"	REAL sumB = 0;\n"
/*201*/		"	int k;\n"
/*202*/		"	for (int x = 0; x < ax; ++x) {\n"
/*203*/		"		for (int y = 0; y < ay; ++y) {\n"
/*204*/		"			k = KTensorMap(x, y, z, ax, ay);\n"
/*205*/		"			sumB += ds[k];\n"
/*206*/		"			sumY += ds[k] * norma[k];\n"
/*207*/		"		}\n"
/*208*/		"	}\n"
/*209*/		"//	printf(\"%d %f %f\\n\",z,gradB[z],gradY[z]);\n"
/*210*/		"	gradB[z] = gradB[z] + sumB / (REAL) batchSize;\n"
/*211*/		"	gradY[z] = gradY[z] + sumY / (REAL) batchSize;\n"
/*212*/		"}\n"
/*213*/		"\n"
/*214*/		"kV BatchNormaLearn(Vector Y, Vector B, Vector gradY, Vector gradB, REAL hit, REAL momento, REAL decaimento, int k0) {\n"
/*215*/		"	int z = get_global_id(0) + k0;\n"
/*216*/		"	Y[z] = Y[z] - hit * (gradY[z] + Y[z] * decaimento);\n"
/*217*/		"	B[z] = B[z] - hit * (gradB[z] + B[z] * decaimento);\n"
/*218*/		"\n"
/*219*/		"	gradY[z] = gradY[z] * momento;\n"
/*220*/		"	gradB[z] = gradB[z] * momento;\n"
/*221*/		"}\n"
/*222*/		"\n"
/*223*/		"\n"
/*224*/		"\n"
/*225*/		"//cnnutils.h\n"
/*226*/		"//\n"
/*227*/		"// Created by Henrique on 22-Jul-21.\n"
/*228*/		"//\n"
/*229*/		"\n"
/*230*/		"\n"
/*231*/		"kV createImg(__global unsigned char *out, Vector v, int vx, int vy, int imi, int imy, int k0) {\n"
/*232*/		"	int k = get_global_id(0) + k0;\n"
/*233*/		"	int i, j, z;\n"
/*234*/		"	KTensorRemap(k, i, j, z, vx, vy)\n"
/*235*/		"	imi = imi + i;\n"
/*236*/		"	int imj = j + z * vy + z;\n"
/*237*/		"	out[imi * imy + imj] = ((int) v[k]) & 0xff;\n"
/*238*/		"}\n"
/*239*/		"\n"
/*240*/		"kV putIMG(__global unsigned char *imagem_saida, Vector v, int z, REAL px, REAL py, int imy, int width, int i0, int j0, int vx, int vy, int k0) {\n"
/*241*/		"	int k = get_global_id(0) + k0;\n"
/*242*/		"	int i, j;\n"
/*243*/		"	KTensorRemap2D(k, i, j, imy)\n"
/*244*/		"	int x = i * px, y = j * py;\n"
/*245*/		"	imagem_saida[(i + i0) * width + j + j0] = ((int) v[KTensorMap(x, y, z, vx, vy)]) & 0xff;\n"
/*246*/		"}\n"
/*247*/		"\n"
/*248*/		"\n"
/*249*/		"kV normalizeVector(Vector input, Vector saida, REAL multiplicador, REAL somador, REAL subtrator, int k0) {\n"
/*250*/		"	int k = get_global_id(0) + k0;\n"
/*251*/		"	saida[k] = (input[k] + somador) * multiplicador - subtrator;\n"
/*252*/		"}\n"
/*253*/		"\n"
/*254*/		"\n"
/*255*/		"kV kernel_sub(Vector ds, Vector s, Vector t, int k0) {\n"
/*256*/		"	int k = get_global_id(0) + k0;\n"
/*257*/		"	ds[k] = s[k] - t[k];\n"
/*258*/		"}\n"
/*259*/		"\n"
/*260*/		"kV kernel_normalizechar2real(Vector dst, __global unsigned char *src, REAL a, REAL b, int k0) {\n"
/*261*/		"	int k = get_global_id(0) + k0;\n"
/*262*/		"//	printf(\"update\\n\");\n"
/*263*/		"	dst[k] = ((REAL) src[k] - b) / a;\n"
/*264*/		"}\n"
/*265*/		"\n"
/*266*/		"kV kernel_getVetorClassFromChar(Vector dst, __global unsigned char *ints, unsigned int noptiobs, int k0) {\n"
/*267*/		"	int w = get_global_id(0) + k0;\n"
/*268*/		"	int y = ints[w];\n"
/*269*/		"	dst[KTensorMap4D(0, y, 0, w, 1, noptiobs, 1)] = 1.0;\n"
/*270*/		"}\n"
/*271*/		"kV kernel_fixW(Vector w, Vector dw, REAL hitlearn, REAL momento, REAL decaimentoDePeso, int k0) {\n"
/*272*/		"	int k = get_global_id(0) + k0;\n"
/*273*/		"	w[k] = w[k] - hitlearn * (dw[k] + w[k] * decaimentoDePeso);\n"
/*274*/		"	dw[k] = dw[k] * momento;\n"
/*275*/		"}\n"
/*276*/		"//conv.h\n"
/*277*/		"kV convSum(Vector filtro, Vector entrada, Vector saida, int passox, int passoy, int saidatx, int saidaty, int entradatx, int entradaty, int fx, int fy, int fz, int k0) {\n"
/*278*/		"	int k = get_global_id(0) + k0;\n"
/*279*/		"	int x, y, filtrok;\n"
/*280*/		"	KTensorRemap(k, x, y, filtrok, saidatx, saidaty)\n"
/*281*/		"	REAL sum = 0, f = 0, v = 0;\n"
/*282*/		"	int lf = 0, le = 0;\n"
/*283*/		"	for (int m = 0; m < fx; m++) {\n"
/*284*/		"		for (int n = 0; n < fy; n++) {\n"
/*285*/		"			for (int z = 0; z < fz; z++) {\n"
/*286*/		"				lf = KTensorMap4D(m, n, z, filtrok, fx, fy, fz);\n"
/*287*/		"				le = KTensorMap(x * passox + m, y * passoy + n, z, entradatx, entradaty);\n"
/*288*/		"				f = filtro[lf];\n"
/*289*/		"				v = entrada[le];\n"
/*290*/		"				sum += f * v;\n"
/*291*/		"			}\n"
/*292*/		"		}\n"
/*293*/		"	}\n"
/*294*/		"	saida[k] = sum;\n"
/*295*/		"}\n"
/*296*/		"\n"
/*297*/		"\n"
/*298*/		"kV convCalcGradAndFixWeight(Vector filtros, Vector ds, Vector entrada, Vector gradFiltro, int fx, int fy, int fz, int entrada_tx, int entrada_ty, int saida_tx, int saida_ty, int passox, int passoy, REAL hitLearn, REAL momento, REAL weightDecay, int k0) {\n"
/*299*/		"	int k = get_global_id(0) + k0;\n"
/*300*/		"	int m, n, z, l;\n"
/*301*/		"	KTensorRemap4D(k, m, n, z, l, fx, fy, fz)\n"
/*302*/		"	REAL soma = 0;\n"
/*303*/		"	int le, ls;\n"
/*304*/		"	for (int i = 0; i < saida_tx; ++i) {\n"
/*305*/		"		for (int j = 0; j < saida_ty; ++j) {\n"
/*306*/		"			le = KTensorMap(i * passox + m, j * passoy + n, z, entrada_tx, entrada_ty);\n"
/*307*/		"			ls = KTensorMap(i, j, l, saida_tx, saida_ty);\n"
/*308*/		"			soma += entrada[le] * ds[ls];\n"
/*309*/		"		}\n"
/*310*/		"	}\n"
/*311*/		"	REAL dw = soma + gradFiltro[k] * momento;\n"
/*312*/		"	REAL w = filtros[k];\n"
/*313*/		"	filtros[k] = w - hitLearn * (dw + w * weightDecay);\n"
/*314*/		"	gradFiltro[k] = dw;\n"
/*315*/		"}\n"
/*316*/		"\n"
/*317*/		"\n"
/*318*/		"kV convCalcGradIn(Vector filtro, Vector gradEntrada, Vector gradNext, int fx, int fy, int fz, int passox, int passoy, int entradatx, int entradaty, int saidatx, int saidaty, int saidatz, int k0) {\n"
/*319*/		"	int k = get_global_id(0) + k0;\n"
/*320*/		"	int x, y, z;\n"
/*321*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*322*/		"\n"
/*323*/		"	Range range_filtro;\n"
/*324*/		"	range_filtro.min.x = 0;\n"
/*325*/		"	if (x + fx > entradatx) {\n"
/*326*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*327*/		"	}\n"
/*328*/		"	range_filtro.max.x = fx - 1;\n"
/*329*/		"	if (x - fx + 1 < 0) {\n"
/*330*/		"		range_filtro.max.x = x;\n"
/*331*/		"	}\n"
/*332*/		"	range_filtro.min.y = 0;\n"
/*333*/		"	if (y + fy > entradaty) {\n"
/*334*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*335*/		"	}\n"
/*336*/		"	range_filtro.max.y = fy - 1;\n"
/*337*/		"	if (y - fy + 1 < 0) {\n"
/*338*/		"		range_filtro.max.y = y;\n"
/*339*/		"	}\n"
/*340*/		"	REAL somaErro = 0, pesoAplicado = 0;\n"
/*341*/		"	int i, j;\n"
/*342*/		"	int lf, ls;\n"
/*343*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*344*/		"		i = (x - m) / passox;\n"
/*345*/		"		if (i * passox + m != x) { continue; }\n"
/*346*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*347*/		"			j = (y - n) / passoy;\n"
/*348*/		"			if (j * passoy + n != y) { continue; }\n"
/*349*/		"			for (int w = 0; w < saidatz; w++) {\n"
/*350*/		"				lf = KTensorMap4D(m, n, z, w, fx, fy, fz);\n"
/*351*/		"				ls = KTensorMap(i, j, w, saidatx, saidaty);\n"
/*352*/		"				pesoAplicado = filtro[lf];\n"
/*353*/		"				somaErro += pesoAplicado * gradNext[ls];\n"
/*354*/		"			}\n"
/*355*/		"		}\n"
/*356*/		"	}\n"
/*357*/		"	gradEntrada[k] = somaErro;\n"
/*358*/		"}\n"
/*359*/		"\n"
/*360*/		"kV convCalcGradBatch(Vector ds, Vector entrada, Vector gradFiltro, long batchSize, int fx, int fy, int fz, int entrada_tx, int entrada_ty, int saida_tx, int saida_ty, int passox, int passoy, int k0) {\n"
/*361*/		"	int k = get_global_id(0) + k0;\n"
/*362*/		"	int m, n, z, l;\n"
/*363*/		"	KTensorRemap4D(k, m, n, z, l, fx, fy, fz)\n"
/*364*/		"	REAL soma = 0;\n"
/*365*/		"	int le, ls;\n"
/*366*/		"	for (int i = 0; i < saida_tx; ++i) {\n"
/*367*/		"		for (int j = 0; j < saida_ty; ++j) {\n"
/*368*/		"			le = KTensorMap(i * passox + m, j * passoy + n, z, entrada_tx, entrada_ty);\n"
/*369*/		"			ls = KTensorMap(i, j, l, saida_tx, saida_ty);\n"
/*370*/		"			soma += entrada[le] * ds[ls];\n"
/*371*/		"		}\n"
/*372*/		"	}\n"
/*373*/		"	soma = soma / batchSize + gradFiltro[k];\n"
/*374*/		"	gradFiltro[k] = soma;\n"
/*375*/		"}\n"
/*376*/		"\n"
/*377*/		"//convf.h\n"
/*378*/		"kV convFSum(Vector filtro, Vector entrada, Vector Z, Vector saida, int passox, int passoy, int saidatx, int saidaty, int entradatx, int entradaty, int fx, int fy, int fz, int fid, int k0) {\n"
/*379*/		"	int k = get_global_id(0) + k0;\n"
/*380*/		"	int x, y, filtrok;\n"
/*381*/		"\n"
/*382*/		"	KTensorRemap(k, x, y, filtrok, saidatx, saidaty)\n"
/*383*/		"	REAL sum = 0, f, v;\n"
/*384*/		"	int lf, le;\n"
/*385*/		"	for (int m = 0; m < fx; m++) {\n"
/*386*/		"		for (int n = 0; n < fy; n++) {\n"
/*387*/		"			for (int z = 0; z < fz; z++) {\n"
/*388*/		"				lf = KTensorMap4D(m, n, z, filtrok, fx, fy, fz);\n"
/*389*/		"				le = KTensorMap(x * passox + m, y * passoy + n, z, entradatx, entradaty);\n"
/*390*/		"				f = filtro[lf];\n"
/*391*/		"				v = entrada[le];\n"
/*392*/		"				sum += f * v;\n"
/*393*/		"			}\n"
/*394*/		"		}\n"
/*395*/		"	}\n"
/*396*/		"	Z[k] = sum;\n"
/*397*/		"	saida[k] = func(fid, sum);\n"
/*398*/		"}\n"
/*399*/		"\n"
/*400*/		"kV convFCalcGradZ(Vector ds, Vector z, Vector dz, int fid, int k0) {\n"
/*401*/		"	int k = get_global_id(0) + k0;\n"
/*402*/		"	dz[k] = ds[k] * func(fid, z[k]);\n"
/*403*/		"}\n"
/*404*/		"\n"
/*405*/		"\n"
/*406*/		"kV convFCalcGradIn(Vector filtro, Vector gradEntrada, Vector dz, int fx, int fy, int fz, int passox, int passoy, int entradatx, int entradaty, int saidatx, int saidaty, int saidatz, int k0) {\n"
/*407*/		"	int k = get_global_id(0) + k0;\n"
/*408*/		"	int x, y, z;\n"
/*409*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*410*/		"\n"
/*411*/		"	Range range_filtro;\n"
/*412*/		"	range_filtro.min.x = 0;\n"
/*413*/		"	if (x + fx > entradatx) {\n"
/*414*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*415*/		"	}\n"
/*416*/		"	range_filtro.max.x = fx - 1;\n"
/*417*/		"	if (x - fx + 1 < 0) {\n"
/*418*/		"		range_filtro.max.x = x;\n"
/*419*/		"	}\n"
/*420*/		"	range_filtro.min.y = 0;\n"
/*421*/		"	if (y + fy > entradaty) {\n"
/*422*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*423*/		"	}\n"
/*424*/		"	range_filtro.max.y = fy - 1;\n"
/*425*/		"	if (y - fy + 1 < 0) {\n"
/*426*/		"		range_filtro.max.y = y;\n"
/*427*/		"	}\n"
/*428*/		"	REAL somaErro = 0, pesoAplicado = 0;\n"
/*429*/		"	int i, j;\n"
/*430*/		"	int lf, ls;\n"
/*431*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*432*/		"		i = (x - m) / passox;\n"
/*433*/		"		if (i * passox + m != x) {\n"
/*434*/		"			continue;\n"
/*435*/		"		}\n"
/*436*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*437*/		"			j = (y - n) / passoy;\n"
/*438*/		"			if (j * passoy + n != y) {\n"
/*439*/		"				continue;\n"
/*440*/		"			}\n"
/*441*/		"			for (int w = 0; w < saidatz; w++) {\n"
/*442*/		"				lf = KTensorMap4D(m, n, z, w, fx, fy, fz);\n"
/*443*/		"				ls = KTensorMap(i, j, w, saidatx, saidaty);\n"
/*444*/		"				pesoAplicado = filtro[lf];\n"
/*445*/		"				somaErro += pesoAplicado * dz[ls];\n"
/*446*/		"			}\n"
/*447*/		"		}\n"
/*448*/		"	}\n"
/*449*/		"	gradEntrada[k] = somaErro;\n"
/*450*/		"}\n"
/*451*/		"\n"
/*452*/		"kV convFCalcGradAndFixWeight(Vector filtros, Vector dz, Vector entrada, Vector gradFiltro, int fx, int fy, int fz, int entrada_tx, int entrada_ty, int saida_tx, int saida_ty, int passox, int passoy, REAL hitLearn, REAL momento, REAL weightDecay, int k0) {\n"
/*453*/		"	int k = get_global_id(0) + k0;\n"
/*454*/		"	int m, n, z, l;\n"
/*455*/		"	KTensorRemap4D(k, m, n, z, l, fx, fy, fz)\n"
/*456*/		"	REAL soma = 0;\n"
/*457*/		"	int le, ls;\n"
/*458*/		"	for (int i = 0; i < saida_tx; ++i) {\n"
/*459*/		"		for (int j = 0; j < saida_ty; ++j) {\n"
/*460*/		"			le = KTensorMap(i * passox + m, j * passoy + n, z, entrada_tx, entrada_ty);\n"
/*461*/		"			ls = KTensorMap(i, j, l, saida_tx, saida_ty);\n"
/*462*/		"			soma += entrada[le] * dz[ls];\n"
/*463*/		"		}\n"
/*464*/		"	}\n"
/*465*/		"	REAL dw = soma + gradFiltro[k] * momento;\n"
/*466*/		"	REAL w = filtros[k];\n"
/*467*/		"	filtros[k] = w - hitLearn * (dw + w * weightDecay);\n"
/*468*/		"	gradFiltro[k] = dw;\n"
/*469*/		"}\n"
/*470*/		"\n"
/*471*/		"kV convFCalcGradBatch(Vector dz, Vector entrada, Vector gradFiltro, long batchSize, int fx, int fy, int fz, int entrada_tx, int entrada_ty, int saida_tx, int saida_ty, int passox, int passoy, int k0) {\n"
/*472*/		"	int k = get_global_id(0) + k0;\n"
/*473*/		"	int m, n, z, l;\n"
/*474*/		"	KTensorRemap4D(k, m, n, z, l, fx, fy, fz)\n"
/*475*/		"	REAL soma = 0;\n"
/*476*/		"	int le, ls;\n"
/*477*/		"	for (int i = 0; i < saida_tx; ++i) {\n"
/*478*/		"		for (int j = 0; j < saida_ty; ++j) {\n"
/*479*/		"			le = KTensorMap(i * passox + m, j * passoy + n, z, entrada_tx, entrada_ty);\n"
/*480*/		"			ls = KTensorMap(i, j, l, saida_tx, saida_ty);\n"
/*481*/		"			soma += entrada[le] * dz[ls];\n"
/*482*/		"		}\n"
/*483*/		"	}\n"
/*484*/		"	soma = soma / batchSize + gradFiltro[k];\n"
/*485*/		"	gradFiltro[k] = soma;\n"
/*486*/		"}\n"
/*487*/		"\n"
/*488*/		"\n"
/*489*/		"//convNc.h\n"
/*490*/		"kV convncSum(Vector W, Vector A, Vector Z, Vector S, unsigned int fid, unsigned int passox, int passoy, unsigned int largx, unsigned int largy, unsigned int entradatx, unsigned int entradaty, unsigned int saidatx, unsigned int saidaty, unsigned int fx, unsigned int fy, unsigned int fz, int k0) {\n"
/*491*/		"	int k = get_global_id(0) + k0;\n"
/*492*/		"	int x, y, filtrok;\n"
/*493*/		"	KTensorRemap(k, x, y, filtrok, saidatx, saidaty)\n"
/*494*/		"	Ponto3d Kmapeado = {x * passox, y * passoy, 0};\n"
/*495*/		"	REAL sum = 0, f, v;\n"
/*496*/		"	for (int i = 0; i < fx; i++) {\n"
/*497*/		"		for (int j = 0; j < fy; j++) {\n"
/*498*/		"			for (int z = 0; z < fz; z++) {\n"
/*499*/		"				f = W[KTensorMap4D(i, j, z, filtrok, fx, fy, fz)];\n"
/*500*/		"				v = A[KTensorMap(Kmapeado.x + i * largx, Kmapeado.y + j * largy, z, entradatx, entradaty)];\n"
/*501*/		"				sum += f * v;\n"
/*502*/		"			}\n"
/*503*/		"		}\n"
/*504*/		"	}\n"
/*505*/		"	Z[k] = sum;\n"
/*506*/		"	S[k] = func(fid, sum);\n"
/*507*/		"}\n"
/*508*/		"\n"
/*509*/		"kV convncCalcGradZ(Vector ds, Vector z, Vector dz, unsigned int fid, int k0) {\n"
/*510*/		"	int k = get_global_id(0) + k0;\n"
/*511*/		"	dz[k] = ds[k] * func(fid, z[k]);\n"
/*512*/		"}\n"
/*513*/		"\n"
/*514*/		"kV convncCalcGrads(Vector W, Vector DA, Vector dz, unsigned int passox, unsigned int passoy, unsigned int largx, unsigned int largy, unsigned int entradatx, unsigned int entradaty, unsigned int saidatx, unsigned int saidaty, unsigned int fx, unsigned int fy, unsigned int fz, int k0) {\n"
/*515*/		"	/**\n"
/*516*/		" * equacao a ser implementada \\n\n"
/*517*/		" * x = s*p + m*w \\n\n"
/*518*/		" * onde: \\n\n"
/*519*/		" * 	x é da entrada \\n\n"
/*520*/		" * 	s é da saida \\n\n"
/*521*/		" * 	m é do filtro\\n\n"
/*522*/		" * 	s = (x - m*w)/p \\n\n"
/*523*/		" */\n"
/*524*/		"	int k = get_global_id(0) + k0;\n"
/*525*/		"	int x, y, z;\n"
/*526*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*527*/		"	Range range_filtro;\n"
/*528*/		"	range_filtro.min.x = 0;\n"
/*529*/		"	if ((entradatx - x - (fx - 1) * largx) < 0) {\n"
/*530*/		"		range_filtro.min.x = -entradatx + x + fx;\n"
/*531*/		"	}\n"
/*532*/		"	range_filtro.max.x = fx - 1;\n"
/*533*/		"	if (x - (fx - 1) * largx < 0) {\n"
/*534*/		"		range_filtro.max.x = x / largx;\n"
/*535*/		"	}\n"
/*536*/		"	range_filtro.min.y = 0;\n"
/*537*/		"	if ((entradaty - y - (fy - 1) * largy) < 0) {\n"
/*538*/		"		range_filtro.min.y = -entradaty + y + fy;\n"
/*539*/		"	}\n"
/*540*/		"	range_filtro.max.y = fy - 1;\n"
/*541*/		"	if (y - (fy - 1) * largy < 0) {\n"
/*542*/		"		range_filtro.max.y = y / largy;\n"
/*543*/		"	}\n"
/*544*/		"	int sx, sy;\n"
/*545*/		"	REAL somaErro = 0, aux, pesoAplicado = 0;\n"
/*546*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*547*/		"		sx = (x - m * largx) / passox;\n"
/*548*/		"		if (sx * passox + m * largx != x) {\n"
/*549*/		"			continue;\n"
/*550*/		"		}\n"
/*551*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*552*/		"			sy = (y - n * largy) / passox;\n"
/*553*/		"			if (sy * passoy + n * largy != y) {\n"
/*554*/		"				continue;\n"
/*555*/		"			}\n"
/*556*/		"			for (int l = 0; l < fz; l++) {\n"
/*557*/		"				pesoAplicado = W[KTensorMap4D(m, n, z, l, fx, fy, fz)];\n"
/*558*/		"				aux = pesoAplicado * dz[KTensorMap(sx, sy, l, saidatx, saidaty)];\n"
/*559*/		"				somaErro += aux;\n"
/*560*/		"			}\n"
/*561*/		"		}\n"
/*562*/		"	}\n"
/*563*/		"	DA[k] = somaErro;\n"
/*564*/		"}\n"
/*565*/		"\n"
/*566*/		"kV convncCalcFiltro(Vector dz, Vector A, Vector W, Vector dW, unsigned int dw_x, unsigned int dw_y, unsigned int dw_z, unsigned int a_x, unsigned int a_y, unsigned int s_x, unsigned int s_y, unsigned int passox, unsigned int passoy, unsigned int largx, unsigned int largy, REAL hitlearn, REAL momento, REAL weightDecay, int k0) {\n"
/*567*/		"	int k = get_global_id(0) + k0;\n"
/*568*/		"	int m, n, z, l;\n"
/*569*/		"	KTensorRemap4D(k, m, n, z, l, dw_x, dw_y, dw_z)\n"
/*570*/		"	REAL soma = 0, aux;\n"
/*571*/		"	for (int i = 0; i < s_x; ++i) {\n"
/*572*/		"		for (int j = 0; j < s_y; ++j) {\n"
/*573*/		"			aux = A[KTensorMap(i * passox + m * largx, j * passoy + n * largy, z, a_x, a_y)] * dz[KTensorMap(i, j, l, s_x, s_y)];\n"
/*574*/		"			soma += aux;\n"
/*575*/		"		}\n"
/*576*/		"	}\n"
/*577*/		"	dW[k] = soma + dW[k] * momento;\n"
/*578*/		"	W[k] = W[k] - hitlearn * (dW[k] + W[k] * weightDecay);\n"
/*579*/		"}\n"
/*580*/		"kV convncCalcFiltroBatch(Vector dz, Vector A, Vector dW,long batchSize, unsigned int dw_x, unsigned int dw_y, unsigned int dw_z, unsigned int a_x, unsigned int a_y, unsigned int s_x, unsigned int s_y, unsigned int passox, unsigned int passoy, unsigned int largx, unsigned int largy, int k0) {\n"
/*581*/		"	int k = get_global_id(0) + k0;\n"
/*582*/		"	int m, n, z, l;\n"
/*583*/		"	KTensorRemap4D(k, m, n, z, l, dw_x, dw_y, dw_z)\n"
/*584*/		"	REAL soma = 0, aux;\n"
/*585*/		"	for (int i = 0; i < s_x; ++i) {\n"
/*586*/		"		for (int j = 0; j < s_y; ++j) {\n"
/*587*/		"			aux = A[KTensorMap(i * passox + m * largx, j * passoy + n * largy, z, a_x, a_y)] * dz[KTensorMap(i, j, l, s_x, s_y)];\n"
/*588*/		"			soma += aux;\n"
/*589*/		"		}\n"
/*590*/		"	}\n"
/*591*/		"	dW[k] = soma/batchSize;\n"
/*592*/		"}\n"
/*593*/		"\n"
/*594*/		"\n"
/*595*/		"\n"
/*596*/		"\n"
/*597*/		"//dropout.h\n"
/*598*/		"#define MAX_INT_DP  ((1UL << 31) - 1)\n"
/*599*/		"long randoml(unsigned long seed,unsigned long id) {\n"
/*600*/		"	seed += id;\n"
/*601*/		"	return (seed * 0x5deece66dL + 0xbL) & MAX_INT_DP;\n"
/*602*/		"}\n"
/*603*/		"\n"
/*604*/		"REAL randomD(unsigned long seed,unsigned long id) {\n"
/*605*/		"	return (REAL) randoml(seed, id) / (REAL) MAX_INT_DP;\n"
/*606*/		"}\n"
/*607*/		"\n"
/*608*/		"kV dropativa(Vector entrada, Vector saida, __global char *hitmap, long seed,\n"
/*609*/		"			 REAL pativa, int k0) {\n"
/*610*/		"	int i = get_global_id(0) + k0;\n"
/*611*/		"//	printf(\"kernel %lf %lf %g %g\\n\",randomD(seed, i),pativa,(REAL)(seed +i),(REAL)MAX_INT_DP);\n"
/*612*/		"	char teste = (char) (randomD(seed, i) <= pativa);\n"
/*613*/		"	hitmap[i] = teste;\n"
/*614*/		"	saida[i] = teste * entrada[i];\n"
/*615*/		"}\n"
/*616*/		"\n"
/*617*/		"\n"
/*618*/		"kV dropcalcgrad(Vector gradentrada, __global char *hitmap, Vector gradnext, int k0) {\n"
/*619*/		"	int i = get_global_id(0) + k0;\n"
/*620*/		"	gradentrada[i] = hitmap[i] * gradnext[i];\n"
/*621*/		"}\n"
/*622*/		"\n"
/*623*/		"//fullconnect.h\n"
/*624*/		"kV fullfeed(Vector a, Vector w, Vector b, Vector z, Vector s, int fid, int w_x, int w_y, int k0) {\n"
/*625*/		"	int m = get_global_id(0) + k0;\n"
/*626*/		"	REAL sum = 0;\n"
/*627*/		"	int n;\n"
/*628*/		"	for (n = 0; n < w_y; n++) {\n"
/*629*/		"		sum += a[n] * w[KTensorMap(m, n, 0, w_x, w_y)];\n"
/*630*/		"	}\n"
/*631*/		"	z[m] = sum + b[m];\n"
/*632*/		"	s[m] = func(fid, z[m]);\n"
/*633*/		"}\n"
/*634*/		"\n"
/*635*/		"kV fullCalcDWandFix(Vector a, Vector w, Vector dw, Vector dz, REAL hitlearn, REAL momento, REAL decaimentoDePeso, int pesosy, int k0) {\n"
/*636*/		"	int k = get_global_id(0) + k0;\n"
/*637*/		"	int m, n;\n"
/*638*/		"	m = k / pesosy;\n"
/*639*/		"	n = k % pesosy;\n"
/*640*/		"	dw[k] = dz[m] * a[n] + dw[k] * momento;\n"
/*641*/		"	w[k] = w[k] - hitlearn * (dw[k] + w[k] * decaimentoDePeso);\n"
/*642*/		"}\n"
/*643*/		"\n"
/*644*/		"\n"
/*645*/		"kV fullCalcDz(Vector dz, Vector ds, Vector z,int dfa, int k0) {\n"
/*646*/		"	int m = get_global_id(0) + k0;\n"
/*647*/		"	dz[m] = ds[m] * func(dfa, z[m]);\n"
/*648*/		"}\n"
/*649*/		"kV fullCalcDzBath(Vector dz, Vector ds, Vector z,  Vector db, int dfa,long batchSize,  int k0) {\n"
/*650*/		"	int m = get_global_id(0) + k0;\n"
/*651*/		"	dz[m] = ds[m] * func(dfa, z[m]);\n"
/*652*/		"	db[m] = dz[m]/batchSize + db[m];\n"
/*653*/		"}\n"
/*654*/		"\n"
/*655*/		"kV fullCalcDzAndFixB(Vector dz, Vector ds, Vector z, Vector b, Vector db, int dfa, REAL hitlearn, REAL momento, REAL decaimentoDePeso, int k0) {\n"
/*656*/		"	int m = get_global_id(0) + k0;\n"
/*657*/		"	dz[m] = ds[m] * func(dfa, z[m]);\n"
/*658*/		"	db[m] = dz[m] + db[m] * momento;\n"
/*659*/		"	b[m] = b[m] - hitlearn * (db[m] + b[m] * decaimentoDePeso);\n"
/*660*/		"}\n"
/*661*/		"\n"
/*662*/		"\n"
/*663*/		"kV fullcalcin(Vector dz, Vector da, Vector w, int pesosx, int pesosy, int k0) {\n"
/*664*/		"	int m = get_global_id(0) + k0;\n"
/*665*/		"	REAL soma = 0;\n"
/*666*/		"	for (int n = 0; n < pesosx; ++n) {\n"
/*667*/		"		soma += dz[n] * w[KTensorMap(n, m, 0, pesosx, pesosy)];\n"
/*668*/		"	}\n"
/*669*/		"	da[m] = soma;\n"
/*670*/		"}\n"
/*671*/		"\n"
/*672*/		"\n"
/*673*/		"kV fullCalcDWBatch(Vector a, Vector dw, Vector dz, long batchSize, int pesosy, int k0) {\n"
/*674*/		"	int k = get_global_id(0) + k0;\n"
/*675*/		"	int m, n;\n"
/*676*/		"	m = k / pesosy;\n"
/*677*/		"	n = k % pesosy;\n"
/*678*/		"	dw[k] = dz[m] * a[n] / batchSize + dw[k];\n"
/*679*/		"}\n"
/*680*/		"\n"
/*681*/		"\n"
/*682*/		"//padding.h\n"
/*683*/		"\n"
/*684*/		"kV paddingfeed(Vector in,Vector out,\n"
/*685*/		"			   unsigned int txi,unsigned int tyi,\n"
/*686*/		"			   unsigned int txo,unsigned int tyo,\n"
/*687*/		"			   unsigned int t, unsigned int l ,\n"
/*688*/		"			   int k0){\n"
/*689*/		"	int k = get_global_id(0) + k0;\n"
/*690*/		"	int x, y, z;\n"
/*691*/		"	KTensorRemap(k, x, y, z, txi, tyi)\n"
/*692*/		"	int s = KTensorMap(x+t,y+l,z,txo,tyo);\n"
/*693*/		"	out[s] = in[k];\n"
/*694*/		"}\n"
/*695*/		"kV paddingBack(Vector gradNext,Vector gradin,\n"
/*696*/		"			   unsigned int txi, unsigned int tyi,\n"
/*697*/		"			   unsigned int txo,unsigned int tyo,\n"
/*698*/		"			   unsigned int t, unsigned int l , int k0){\n"
/*699*/		"	int k = get_global_id(0) + k0;\n"
/*700*/		"	int x, y, z;\n"
/*701*/		"	KTensorRemap(k, x, y, z, txi, tyi)\n"
/*702*/		"	int s = KTensorMap(x+t,y+l,z,txo,tyo);\n"
/*703*/		"	gradin[k] = gradNext[s];\n"
/*704*/		"}\n"
/*705*/		"//poolav.h\n"
/*706*/		"kV poolAVativa(Vector entrada, Vector saida,\n"
/*707*/		"			   int passox, int passoy,\n"
/*708*/		"			   int fx, int fy,\n"
/*709*/		"			   int saidatx, int saidaty, int entradatx, int entradaty, int k0) {\n"
/*710*/		"	int k = get_global_id(0) + k0;\n"
/*711*/		"	int x, y, z;\n"
/*712*/		"	KTensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*713*/		"\n"
/*714*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*715*/		"	REAL soma = 0;\n"
/*716*/		"\n"
/*717*/		"	for (int i = 0; i < fx; ++i) {\n"
/*718*/		"		for (int j = 0; j < fy; ++j) {\n"
/*719*/		"			soma += entrada[KTensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*720*/		"		}\n"
/*721*/		"	}\n"
/*722*/		"	saida[k] = soma / (fx * fy);\n"
/*723*/		"}\n"
/*724*/		"\n"
/*725*/		"\n"
/*726*/		"kV poolAvCalcGrads(Vector entrada, Vector gradEntrada, Vector gradNext, Vector saida,\n"
/*727*/		"				   int fx, int fy, int px, int py,\n"
/*728*/		"				   int entradatx, int entradaty,\n"
/*729*/		"				   int saidatx, int saidaty,\n"
/*730*/		"				   int k0) {\n"
/*731*/		"	int k = get_global_id(0) + k0;\n"
/*732*/		"	int x, y, z;\n"
/*733*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*734*/		"	Range range_filtro;\n"
/*735*/		"	range_filtro.min.x = 0;\n"
/*736*/		"	if (x + fx > entradatx) {\n"
/*737*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*738*/		"	}\n"
/*739*/		"	range_filtro.max.x = fx - 1;\n"
/*740*/		"	if (x - fx + 1 < 0) {\n"
/*741*/		"		range_filtro.max.x = x;\n"
/*742*/		"	}\n"
/*743*/		"	range_filtro.min.y = 0;\n"
/*744*/		"	if (y + fy > entradaty) {\n"
/*745*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*746*/		"	}\n"
/*747*/		"	range_filtro.max.y = fy - 1;\n"
/*748*/		"	if (y - fy + 1 < 0) {\n"
/*749*/		"		range_filtro.max.y = y;\n"
/*750*/		"	}\n"
/*751*/		"	int i, j;//saida\n"
/*752*/		"	REAL soma = 0;\n"
/*753*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*754*/		"		i = (x - m) / px;\n"
/*755*/		"		if (i * px + m != x)continue;\n"
/*756*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*757*/		"			j = (y - n) / py;\n"
/*758*/		"			if (j * py + n != y)continue;\n"
/*759*/		"			soma += gradNext[KTensorMap(i, j, z, saidatx, saidaty)];\n"
/*760*/		"		}\n"
/*761*/		"	}\n"
/*762*/		"	gradEntrada[KTensorMap(x, y, z, entradatx, entradaty)] = soma / (fx * fy);\n"
/*763*/		"\n"
/*764*/		"}\n"
/*765*/		"\n"
/*766*/		"\n"
/*767*/		"//poolMax.h\n"
/*768*/		"kV poolativa(Vector entrada, Vector saida,\n"
/*769*/		"			 int passox, int passoy,\n"
/*770*/		"			 int filtrox, int filtroy,\n"
/*771*/		"			 int saidatx, int saidaty,\n"
/*772*/		"			 int entradatx, int entradaty, int k0) {\n"
/*773*/		"	int k = get_global_id(0) + k0;\n"
/*774*/		"	int x, y, z;\n"
/*775*/		"	KTensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*776*/		"\n"
/*777*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*778*/		"	REAL mval, v;\n"
/*779*/		"	mval = -DBL_MAX;\n"
/*780*/		"	for (int i = 0; i < filtrox; ++i) {\n"
/*781*/		"		for (int j = 0; j < filtroy; ++j) {\n"
/*782*/		"			v = entrada[KTensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*783*/		"			if (v > mval)\n"
/*784*/		"				mval = v;\n"
/*785*/		"		}\n"
/*786*/		"	}\n"
/*787*/		"	saida[k] = mval;\n"
/*788*/		"}\n"
/*789*/		"\n"
/*790*/		"\n"
/*791*/		"kV poolCalcGrads(Vector entrada, Vector gradEntrada,\n"
/*792*/		"				 Vector gradNext, Vector saida,\n"
/*793*/		"				 int fx, int fy, int px, int py,\n"
/*794*/		"				 int entradatx, int entradaty,\n"
/*795*/		"				 int saidatx, int saidaty,\n"
/*796*/		"				 int k0) {\n"
/*797*/		"	int k = get_global_id(0) + k0;\n"
/*798*/		"	int x, y, z;\n"
/*799*/		"	KTensorRemap(k, x, y, z, entradatx, entradaty)\n"
/*800*/		"	Range range_filtro;\n"
/*801*/		"	if (x + fx > entradatx) {\n"
/*802*/		"		range_filtro.min.x = x + fx - entradatx;\n"
/*803*/		"	}\n"
/*804*/		"	range_filtro.max.x = fx - 1;\n"
/*805*/		"	if (x - fx + 1 < 0) {\n"
/*806*/		"		range_filtro.max.x = x;\n"
/*807*/		"	}\n"
/*808*/		"	range_filtro.min.y = 0;\n"
/*809*/		"	if (y + fy > entradaty) {\n"
/*810*/		"		range_filtro.min.y = y + fy - entradaty;\n"
/*811*/		"	}\n"
/*812*/		"	range_filtro.max.y = fy - 1;\n"
/*813*/		"	if (y - fy + 1 < 0) {\n"
/*814*/		"		range_filtro.max.y = y;\n"
/*815*/		"	}\n"
/*816*/		"	int i, j;//saida\n"
/*817*/		"	gradEntrada[KTensorMap(x, y, z, entradatx, entradaty)] = 0;\n"
/*818*/		"	for (int m = range_filtro.min.x; m <= range_filtro.max.x; m++) {\n"
/*819*/		"		i = (x - m) / px;\n"
/*820*/		"		if (i * px + m != x)continue;\n"
/*821*/		"		for (int n = range_filtro.min.y; n <= range_filtro.max.y; n++) {\n"
/*822*/		"			j = (y - n) / py;\n"
/*823*/		"			if (j * py + n != y)continue;\n"
/*824*/		"			if (entrada[k] == saida[KTensorMap(i, j, z, saidatx, saidaty)]) {\n"
/*825*/		"				gradEntrada[k] = gradNext[KTensorMap(i, j, z, saidatx, saidaty)];\n"
/*826*/		"				return;\n"
/*827*/		"			}\n"
/*828*/		"		}\n"
/*829*/		"	}\n"
/*830*/		"\n"
/*831*/		"}\n"
/*832*/		"\n"
/*833*/		"\n"
/*834*/		"//poolMin.h\n"
/*835*/		"kV poolativaMin(Vector entrada, Vector saida,\n"
/*836*/		"				int passox, int passoy,\n"
/*837*/		"				int filtrox, int filtroy,\n"
/*838*/		"				int saidatx, int saidaty,\n"
/*839*/		"				int entradatx, int entradaty, int k0) {\n"
/*840*/		"	int k = get_global_id(0) + k0;\n"
/*841*/		"	int x, y, z;\n"
/*842*/		"	KTensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*843*/		"\n"
/*844*/		"	Ponto3d mapeado = {x * passox, y * passoy, 0};\n"
/*845*/		"	REAL mval, v;\n"
/*846*/		"	mval = DBL_MAX;\n"
/*847*/		"	for (int i = 0; i < filtrox; ++i) {\n"
/*848*/		"		for (int j = 0; j < filtroy; ++j) {\n"
/*849*/		"			v = entrada[KTensorMap(mapeado.x + i, mapeado.y + j, z, entradatx, entradaty)];\n"
/*850*/		"			if (v < mval)\n"
/*851*/		"				mval = v;\n"
/*852*/		"		}\n"
/*853*/		"	}\n"
/*854*/		"	saida[k] = mval;\n"
/*855*/		"}\n"
/*856*/		"\n"
/*857*/		"\n"
/*858*/		"//prelu.h\n"
/*859*/		"kV preluativa(Vector entrada, Vector saida, Vector A, int k0) {\n"
/*860*/		"	int k = get_global_id(0) + k0;\n"
/*861*/		"	REAL v = entrada[k];\n"
/*862*/		"	if (v < 0) {\n"
/*863*/		"		v = v * A[k];\n"
/*864*/		"	}\n"
/*865*/		"	saida[k] = v;\n"
/*866*/		"}\n"
/*867*/		"\n"
/*868*/		"kV prelucalcgrad(Vector gradentrada, Vector entrada, Vector gradnext, Vector A, Vector dA, int learn, REAL hitlearn, REAL momento, REAL decaimento, int k0) {\n"
/*869*/		"	int k = get_global_id(0) + k0;\n"
/*870*/		"	REAL v = entrada[k];\n"
/*871*/		"	if (v < 0) {\n"
/*872*/		"		gradentrada[k] = gradnext[k] * A[k];\n"
/*873*/		"		dA[k] = gradnext[k] + momento * dA[k];\n"
/*874*/		"	} else {\n"
/*875*/		"		gradentrada[k] = gradnext[k];\n"
/*876*/		"		dA[k] = momento * dA[k];\n"
/*877*/		"	}\n"
/*878*/		"	if (learn) {\n"
/*879*/		"		A[k] = A[k] - hitlearn * (dA[k] + A[k] * decaimento);\n"
/*880*/		"	}\n"
/*881*/		"}\n"
/*882*/		"\n"
/*883*/		"kV preluonlyfix(Vector entrada, Vector gradnext, Vector A, Vector dA, REAL hitlearn, REAL momento, REAL decaimento, int k0) {\n"
/*884*/		"	int k = get_global_id(0) + k0;\n"
/*885*/		"	REAL v = entrada[k];\n"
/*886*/		"	if (v < 0) {\n"
/*887*/		"		dA[k] = gradnext[k] + momento * dA[k];\n"
/*888*/		"	} else {\n"
/*889*/		"		dA[k] = momento * dA[k];\n"
/*890*/		"	}\n"
/*891*/		"	A[k] = A[k] - hitlearn * (dA[k] + A[k] * decaimento);\n"
/*892*/		"}\n"
/*893*/		"\n"
/*894*/		"kV prelucalcgradBatch(Vector gradentrada, Vector entrada, Vector gradnext, Vector A, Vector dA, long batchSize, int k0) {\n"
/*895*/		"	int k = get_global_id(0) + k0;\n"
/*896*/		"	REAL v = entrada[k];\n"
/*897*/		"	if (v < 0) {\n"
/*898*/		"		gradentrada[k] = gradnext[k] * A[k];\n"
/*899*/		"		dA[k] = gradnext[k] / batchSize + dA[k];\n"
/*900*/		"	} else {\n"
/*901*/		"		gradentrada[k] = gradnext[k];\n"
/*902*/		"		dA[k] = 1.0 / batchSize + dA[k];\n"
/*903*/		"	}\n"
/*904*/		"}\n"
/*905*/		"\n"
/*906*/		"kV preluonlyDABatch(Vector entrada, Vector gradnext, Vector A, Vector dA, long batchSize, int k0) {\n"
/*907*/		"	int k = get_global_id(0) + k0;\n"
/*908*/		"	REAL v = entrada[k];\n"
/*909*/		"	if (v < 0) {\n"
/*910*/		"		dA[k] = gradnext[k] / batchSize + dA[k];\n"
/*911*/		"	} else {\n"
/*912*/		"		dA[k] = 1.0 / batchSize + dA[k];\n"
/*913*/		"	}\n"
/*914*/		"}\n"
/*915*/		"//relu.h\n"
/*916*/		"\n"
/*917*/		"kV reluativa(Vector entrada, Vector saida, REAL menor, REAL maior, int k0) {\n"
/*918*/		"	int k = get_global_id(0) + k0;\n"
/*919*/		"	saida[k] = entrada[k] < 0.0 ? (entrada[k] * menor) : (entrada[k] * maior);\n"
/*920*/		"}\n"
/*921*/		"\n"
/*922*/		"\n"
/*923*/		"kV relucalcgrad(Vector gradentrada, Vector entrada, Vector gradnext, REAL menor, REAL maior, int k0) {\n"
/*924*/		"	int k = get_global_id(0) + k0;\n"
/*925*/		"	gradentrada[k] = entrada[k] < 0.0 ? (menor * gradnext[k]) : (maior * gradnext[k]);\n"
/*926*/		"}\n"
/*927*/		"\n"
/*928*/		"//softmax.h\n"
/*929*/		"/**\n"
/*930*/		" * @goal calcular e^a(x,y,z)\n"
/*931*/		" * @iteration dimensão de a (x,y,z)\n"
/*932*/		" * @param entrada Tensor de entrada (leitura)\n"
/*933*/		" * @param exponent Tensor e^entrada (escrita)\n"
/*934*/		" * @param k0 usado internamente no kernel\n"
/*935*/		" */\n"
/*936*/		"kV softmaxExp(Vector entrada, Vector exponent, int k0) {\n"
/*937*/		"	int k = get_global_id(0) + k0;\n"
/*938*/		"	exponent[k] = EXP(entrada[k]);\n"
/*939*/		"}\n"
/*940*/		"\n"
/*941*/		"/***\n"
/*942*/		" * @goal encontrar a soma de cada dimensão z\n"
/*943*/		" * @iteration dimensão z da entrada a(:,:,z)\n"
/*944*/		" * @param eps Tensor exponencial da entrada (leitura)\n"
/*945*/		" * @param soma Tensor da soma das exponenciais (escrita)\n"
/*946*/		" * @param saidatx dimensão x da saída\n"
/*947*/		" * @param saidaty dimensão x da saída\n"
/*948*/		" * @param k0 usado internamente no kernel\n"
/*949*/		" */\n"
/*950*/		"kV softmaxSomaExp(Vector eps, Vector soma, int saidatx, int saidaty, int k0) {\n"
/*951*/		"	int z = get_global_id(0) + k0;\n"
/*952*/		"	int x, y;\n"
/*953*/		"	REAL sum = 0;\n"
/*954*/		"	for (x = 0; x < saidatx; x++) {\n"
/*955*/		"		for (y = 0; y < saidaty; y++) {\n"
/*956*/		"			sum += eps[KTensorMap(x, y, z, saidatx, saidaty)];\n"
/*957*/		"		}\n"
/*958*/		"	}\n"
/*959*/		"	soma[z] = sum;\n"
/*960*/		"}\n"
/*961*/		"/***\n"
/*962*/		" * @goal Normalizar a exponencial pela soma\n"
/*963*/		" *  * @iteration dimensão da saída  s(x,y,z)\n"
/*964*/		" * @param exponet Tensor exponencial da entrada (leitura)\n"
/*965*/		" * @param soma Tensor da soma das exponenciais (leitura)\n"
/*966*/		" * @param saida Tensor de saída (escrita)\n"
/*967*/		" * @param saidatx dimensão x da saída\n"
/*968*/		" * @param saidaty dimensão x da saída\n"
/*969*/		" * @param k0 usado internamente no kernel\n"
/*970*/		" */\n"
/*971*/		"kV softmaxNormaliza(Vector exponet, Vector soma, Vector saida, int saidatx, int saidaty, int k0) {\n"
/*972*/		"	int k = get_global_id(0) + k0;\n"
/*973*/		"	int x, y, z;\n"
/*974*/		"	KTensorRemap(k, x, y, z, saidatx, saidaty)\n"
/*975*/		"	saida[k] = exponet[k] / soma[z];\n"
/*976*/		"}\n"
/*977*/		"/**\n"
/*978*/		" * @goal Calcular os gradientes de entrada\n"
/*979*/		" * @iteration dimensão da entrada a(x,y,z)\n"
/*980*/		" * @param da Tensor de gradientes de entrada (escrita)\n"
/*981*/		" * @param s Tensor de saida (leitura)\n"
/*982*/		" * @param ds Tensor gradiente da saída (leitura)\n"
/*983*/		" * @param sx dimensão x da saída\n"
/*984*/		" * @param sy dimensão y da saída\n"
/*985*/		" * @param k0 usado internamente no kernel\n"
/*986*/		" */\n"
/*987*/		"kV softMaxcalcgrad(Vector da, Vector s, Vector ds, int sx, int sy, int k0) {\n"
/*988*/		"	int k = get_global_id(0) + k0;\n"
/*989*/		"	int i, z, j;\n"
/*990*/		"	int sxy = sx * sy;\n"
/*991*/		"	KTensorRemap2D(k, z, i, sxy);\n"
/*992*/		"	REAL yi = s[k];\n"
/*993*/		"	REAL soma = 0.0;\n"
/*994*/		"	for (j = 0; j < sxy; ++j) {\n"
/*995*/		"		if (j == i) {\n"
/*996*/		"			soma += yi * (1 - yi) * ds[j + z * sxy];\n"
/*997*/		"//			printf(\"v(%d,%d,%d) =  %f, %f %f;\\n\", i+1, j+1, z+1, yi * (1 - yi),s[j + z * sxy],yi);\n"
/*998*/		"		} else {\n"
/*999*/		"			soma += -yi * s[j + z * sxy] * ds[j + z * sxy];\n"
/*1000*/		"//			printf(\"v(%d,%d,%d) =  %f, %f %f;\\n\", i+1, j+1, z+1, yi * -s[j + z * sxy],s[j + z * sxy],yi);\n"
/*1001*/		"		}\n"
/*1002*/		"	}\n"
/*1003*/		"	da[k] = soma;\n"
/*1004*/		"}\n"
/*1005*/		"\n"
/*1006*/		"/**\n"
/*1007*/		" * @goal Encontrar o maximo e o indice de cada dimensão z\n"
/*1008*/		" * @iteration dimensão z da entrada a(:,:,z)\n"
/*1009*/		" * @param a entrada\n"
/*1010*/		" * @param mx tensor maximos\n"
/*1011*/		" * @param i_max tensor indice de maximos\n"
/*1012*/		" * @param ax entrada x\n"
/*1013*/		" * @param ay entrada y\n"
/*1014*/		" * @param k0 uso interno no kernel\n"
/*1015*/		" */\n"
/*1016*/		"kV softmaxFindMax(Vector a, Vector mx, __global int *i_max, int ax, int ay, int k0) {\n"
/*1017*/		"	int z = get_global_id(0) + k0;\n"
/*1018*/		"	int x, y;\n"
/*1019*/		"	REAL maximo = a[KTensorMap(0, 0, z, ax, ay)];\n"
/*1020*/		"	REAL adata;\n"
/*1021*/		"	int imax = 0;\n"
/*1022*/		"	for (x = 0; x < ax; x++) {\n"
/*1023*/		"		for (y = 0; y < ay; y++) {\n"
/*1024*/		"			adata = a[KTensorMap(x, y, z, ax, ay)];\n"
/*1025*/		"			if (maximo < adata) {\n"
/*1026*/		"				maximo = adata;\n"
/*1027*/		"				imax = x * ay + y;\n"
/*1028*/		"			}\n"
/*1029*/		"		}\n"
/*1030*/		"	}\n"
/*1031*/		"	i_max[z] = imax;\n"
/*1032*/		"	mx[z] = maximo;\n"
/*1033*/		"}\n"
/*1034*/		"\n"
/*1035*/		"/**\n"
/*1036*/		" * @goal calcular e^(a(x,y,z) - max(a))\n"
/*1037*/		" * @iteration dimensão de a (x,y,z)\n"
/*1038*/		" * @param entrada Tensor de entrada (leitura)\n"
/*1039*/		" * @param exponent Tensor e^entrada (escrita)\n"
/*1040*/		" * @param mx tensor maximos\n"
/*1041*/		" * @param ax entrada x\n"
/*1042*/		" * @param ay entrada y\n"
/*1043*/		" * @param k0 usado internamente no kernel\n"
/*1044*/		" */\n"
/*1045*/		"kV softmaxExpNorm(Vector entrada, Vector exponent, Vector mx, int ax, int ay, int k0) {\n"
/*1046*/		"	int k = get_global_id(0) + k0;\n"
/*1047*/		"	int x, y, z;\n"
/*1048*/		"	KTensorRemap(k, x, y, z, ax, ay);\n"
/*1049*/		"	exponent[k] = EXP(entrada[k] - mx[z]);\n"
/*1050*/		"}\n"
/*1051*/		"\n"
/*1052*/		"#endif //GAB_KERNELS_OPENCL_H\n"
;
const char *getInternalDefaultKernel() {
	return __default_kernel__;
}